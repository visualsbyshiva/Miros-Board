<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Smart Product Recommendations</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script type="module" src="https://content.miros.services/frontend/public/main/container/assets/container.bundle.js" data-miros-integration-id="fb97f7d4-fe95-402f-a81a-402cb062eaa3"></script>
  </head>
  <body>
    <div class="focus-overlay" id="focusOverlay"></div>
    <main class="dashboard">
      <header class="dashboard__header" id="dashboardHeader">
        <div class="dashboard__header-content">
          <div class="dashboard__header-title">
            <h1 class="dashboard__title">Smart Product Recommendations</h1>
            <p class="dashboard__subtitle">Paste a link, SKU, or product name to find similar items</p>
          </div>
          <div class="dashboard__search-container">
            <div class="dashboard__search-inline">
              <button
                type="button"
                class="dashboard__button dashboard__button--image-icon"
                id="uploadTrigger"
                aria-label="Upload Image"
                title="Upload Image"
              >
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <g transform="translate(3.5, 3.5)">
                    <path d="M1.80775 17C1.30258 17 0.875 16.825 0.525 16.475C0.175 16.125 0 15.6974 0 15.1923V1.80775C0 1.30258 0.175 0.875 0.525 0.525C0.875 0.175 1.30258 0 1.80775 0H8.55775C8.77025 0 8.94833 0.0719168 9.092 0.21575C9.23583 0.359583 9.30775 0.53775 9.30775 0.75025C9.30775 0.962917 9.23583 1.141 9.092 1.2845C8.94833 1.42817 8.77025 1.5 8.55775 1.5H1.80775C1.71792 1.5 1.64417 1.52883 1.5865 1.5865C1.52883 1.64417 1.5 1.71792 1.5 1.80775V15.1923C1.5 15.2821 1.52883 15.3558 1.5865 15.4135C1.64417 15.4712 1.71792 15.5 1.80775 15.5H15.1923C15.2821 15.5 15.3558 15.4712 15.4135 15.4135C15.4712 15.3558 15.5 15.2821 15.5 15.1923V8.44225C15.5 8.22975 15.5719 8.05167 15.7158 7.908C15.8596 7.76417 16.0378 7.69225 16.2502 7.69225C16.4629 7.69225 16.641 7.76417 16.7845 7.908C16.9282 8.05167 17 8.22975 17 8.44225V15.1923C17 15.6974 16.825 16.125 16.475 16.475C16.125 16.825 15.6974 17 15.1923 17H1.80775ZM2.88475 13.1923H14.1152L10.625 8.5385L7.625 12.4327L5.5 9.73075L2.88475 13.1923ZM13.5 3.5H12.25C12.0375 3.5 11.8593 3.42808 11.7155 3.28425C11.5718 3.14042 11.5 2.96225 11.5 2.74975C11.5 2.53708 11.5718 2.359 11.7155 2.2155C11.8593 2.07183 12.0375 2 12.25 2H13.5V0.75C13.5 0.5375 13.5719 0.359417 13.7158 0.21575C13.8596 0.0719168 14.0378 0 14.2503 0C14.4629 0 14.641 0.0719168 14.7845 0.21575C14.9282 0.359417 15 0.5375 15 0.75V2H16.25C16.4625 2 16.6406 2.07192 16.7843 2.21575C16.9281 2.35958 17 2.53775 17 2.75025C17 2.96292 16.9281 3.141 16.7843 3.2845C16.6406 3.42817 16.4625 3.5 16.25 3.5H15V4.75C15 4.9625 14.9281 5.14067 14.7843 5.2845C14.6404 5.42817 14.4622 5.5 14.2498 5.5C14.0371 5.5 13.859 5.42817 13.7155 5.2845C13.5718 5.14067 13.5 4.9625 13.5 4.75V3.5Z" fill="#1C1B1F"/>
                  </g>
                </svg>
              </button>
              <div class="dashboard__input-wrapper">
        <input
          type="text"
          class="dashboard__input"
          id="searchInput"
                  placeholder="Paste a Product URL, SKU or a Product Attribute"
                  aria-label="Enter search term, SKU, or paste product URL"
        />
              </div>
              <div class="dashboard__category-wrapper" style="display: none;">
        <select
          class="dashboard__select"
          id="categorySelect"
          aria-label="Select product category"
                  disabled
        >
          <option value="Fashion">Fashion</option>
          <option value="Womenswear">Womenswear</option>
          <option value="Menswear">Menswear</option>
          <option value="Accessories">Accessories</option>
          <option value="Footwear">Footwear</option>
        </select>
              </div>
        <button
          type="button"
                class="dashboard__button dashboard__button--search"
          id="searchButton"
                aria-label="Search"
                title="Search"
        >
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M9 17C13.4183 17 17 13.4183 17 9C17 4.58172 13.4183 1 9 1C4.58172 1 1 4.58172 1 9C1 13.4183 4.58172 17 9 17Z" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M19 19L14.65 14.65" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
        </button>
        <div
          id="mirosEntry"
          data-miros-entry="miros-on-search"
          aria-hidden="true"
        ></div>
            </div>
            <input
              type="file"
              id="uploadInput"
              accept="image/*"
              hidden
              aria-hidden="true"
            />
          </div>
        </div>
      </header>
      <p class="dashboard__status" id="statusMessage" aria-live="polite"></p>
      <section class="dashboard__results" id="dashboardResults">
            <div>
          <div class="results-summary" id="resultsSummary" style="display: none;">
            <span class="results-summary__text" id="resultsSummaryText">
              Enter a search term, SKU ID, or upload an image to see product-level recommendations here.
            </span>
          </div>
          <div class="results-grid-wrapper" role="region" aria-live="polite">
            <table class="results-grid" id="resultsGrid">
              <thead>
                <tr>
                  <th scope="col">Product Image</th>
                  <th scope="col">Product Title</th>
                  <th scope="col">SKU / Product ID</th>
                  <th scope="col">Product URL</th>
                </tr>
              </thead>
              <tbody id="resultsBody">
                <tr>
                  <td colspan="4" class="results-empty">
                    Waiting for your first search…
                  </td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
      </section>
      <footer class="dashboard__footer" id="dashboardFooter">
        <div class="dashboard__pagination" id="paginationContainer"></div>
        <div class="dashboard__footer-actions">
          <button type="button" class="dashboard__button dashboard__button--ghost" id="clearResultsButton">Clear Results</button>
          <button type="button" class="dashboard__button dashboard__button--primary" id="downloadButton">Export as CSV</button>
        </div>
      </footer>
    </main>
    <script>
      (function () {
        const trigger = document.getElementById("uploadTrigger");
        const fileInput = document.getElementById("uploadInput");
        const searchBtn = document.getElementById("searchButton");
        const searchInput = document.getElementById("searchInput");
        const categorySelect = document.getElementById("categorySelect");
        const mirosEntry = document.getElementById("mirosEntry");
        const statusMessage = document.getElementById("statusMessage");
        const resultsSummary = document.getElementById("resultsSummary");
        const resultsSummaryText = document.getElementById("resultsSummaryText");
        const resultsBody = document.getElementById("resultsBody");
        const clearResultsBtn = document.getElementById("clearResultsButton");
        const downloadButton = document.getElementById("downloadButton");
        const dashboardResults = document.getElementById("dashboardResults");
        const dashboardHeader = document.getElementById("dashboardHeader");
        const focusOverlay = document.getElementById("focusOverlay");

        // State management
        let hasSearched = false;
        let isFocusMode = false;
        let allProducts = []; // Store all scraped products
        let currentPage = 1;
        const itemsPerPage = 20;
        let statusHideTimer = null;
        let lastStatusUpdate = 0;
        let lastStatusText = "";

        // STATE 1: Initial State - hide results on first load
        if (dashboardResults) {
          dashboardResults.style.display = 'none';
        }
        const footer = document.querySelector('.dashboard__footer');
        if (footer) {
          footer.style.display = 'none';
        }

        // Note: Search button handlers are set up later in performSearch section

        // STATE 3: Focus Mode - when clicking search input after search
        const enterFocusMode = () => {
          if (!hasSearched) return; // Only work in STATE 2
          
          isFocusMode = true;
          document.body.classList.add('focus-mode');
          if (focusOverlay) {
            focusOverlay.classList.add('active');
          }
          if (dashboardHeader) {
            dashboardHeader.classList.add('focused');
          }
          if (dashboardResults) {
            dashboardResults.classList.add('faded');
          }
          const footer = document.querySelector('.dashboard__footer');
          if (footer) {
            footer.classList.add('faded');
          }
        };

        // Exit focus mode - return to STATE 2
        const exitFocusMode = () => {
          isFocusMode = false;
          document.body.classList.remove('focus-mode');
          if (focusOverlay) {
            focusOverlay.classList.remove('active');
          }
          if (dashboardHeader) {
            dashboardHeader.classList.remove('focused');
          }
          if (dashboardResults) {
            dashboardResults.classList.remove('faded');
          }
          const footer = document.querySelector('.dashboard__footer');
          if (footer) {
            footer.classList.remove('faded');
          }
        };

        // Show results section after first search - STATE 2: Searched State
        const showResultsSection = () => {
          if (hasSearched) return; // Already shown, don't duplicate
          
          hasSearched = true;
          document.body.classList.add('has-results');
          
          if (dashboardResults) {
            dashboardResults.style.display = 'flex';
            // Force reflow to ensure display change takes effect
            void dashboardResults.offsetHeight;
            // Add visible class for animation
            requestAnimationFrame(() => {
              dashboardResults.classList.add('visible');
            });
          }
          
          const footer = document.querySelector('.dashboard__footer');
          if (footer) {
            footer.style.display = 'flex';
            requestAnimationFrame(() => {
              footer.classList.add('visible');
            });
          }
          
          // Exit focus mode if active
          exitFocusMode();
        };

        // Focus mode: click overlay to exit
        if (focusOverlay) {
          focusOverlay.addEventListener('click', (e) => {
            if (isFocusMode && e.target === focusOverlay) {
              exitFocusMode();
              searchInput?.blur();
            }
          });
        }

        // Enter focus mode on search input focus (only after first search)
        if (searchInput) {
          searchInput.addEventListener('focus', () => {
            if (hasSearched) {
              enterFocusMode();
            }
          });

          // Exit focus mode on blur
          searchInput.addEventListener('blur', (e) => {
            setTimeout(() => {
              if (!document.activeElement || 
                  (document.activeElement.id !== 'searchButton' && 
                   document.activeElement.id !== 'uploadTrigger')) {
                exitFocusMode();
              }
            }, 200);
          });

          // Auto-detect paste and trigger search
          searchInput.addEventListener('paste', (e) => {
            setTimeout(() => {
              const pastedValue = searchInput.value.trim();
              if (pastedValue && (pastedValue.startsWith('http') || pastedValue.includes('/p/'))) {
                // Auto-trigger search for URLs
                if (searchBtn) {
                  setTimeout(() => {
                    searchBtn.click();
                  }, 100);
                }
              }
            }, 10);
          });

          const triggerSearchOnEnter = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              exitFocusOnSearch();
              performSearch();
            }
          };

          // Also listen globally so Enter works even when focus mode overlay is active
          document.addEventListener('keydown', (e) => {
            if (document.activeElement === searchInput) {
              triggerSearchOnEnter(e);
            }
          });
        }

        // Exit focus mode when search button is clicked - returns to STATE 2
        const exitFocusOnSearch = () => {
          exitFocusMode();
        };

        const ENTRY_ATTRS = [
          "item",
          "nlp",
          "category",
          "image-url",
          "sizes",
          "lang",
        ];

        const deriveProductIdFromSource = (productUrl = "", fallbackValue = "") => {
          if (productUrl) {
            const match = String(productUrl).match(/\/p\/([^/?]+)/i);
            if (match && match[1]) {
              return decodeURIComponent(match[1]);
            }
          }
          const normalizedFallback =
            typeof fallbackValue === "number"
              ? String(fallbackValue)
              : (fallbackValue || "").toString().trim();
          return normalizedFallback || "-";
        };

        // This helper shows a friendly status message so people know what is happening.
        const showStatus = (message, type = "info", options = {}) => {
          if (!statusMessage) return;
          const { autoHideDelay = 6000 } = options;
          
          statusMessage.textContent = message;
          statusMessage.dataset.status = type;
          statusMessage.classList.add("visible");
          lastStatusText = message;
          lastStatusUpdate = Date.now();
          
          if (statusHideTimer) {
            clearTimeout(statusHideTimer);
            statusHideTimer = null;
          }
          
          if (type === "pending") {
            statusHideTimer = setTimeout(() => {
              const isStale = Date.now() - lastStatusUpdate >= autoHideDelay - 50;
              if (isStale) {
                clearStatus();
              }
            }, autoHideDelay);
          }
        };

        // This helper wipes the status text when we are done talking to the user.
        const clearStatus = () => {
          if (!statusMessage) return;
          if (statusHideTimer) {
            clearTimeout(statusHideTimer);
            statusHideTimer = null;
          }
          statusMessage.textContent = "";
          statusMessage.dataset.status = "";
          statusMessage.classList.remove("visible");
          lastStatusText = "";
        };

        // This helper turns the raw number of hits into a short sentence kids can read.
        const summariseResults = (count) => {
          if (!resultsSummaryText) return;

          if (!count) {
            resultsSummaryText.textContent =
              "No matches returned from Miros. Adjust filters or try another input.";
            return;
          }

          resultsSummaryText.textContent = `${count} product${
            count === 1 ? "" : "s"
          } returned from Miros.`;
        };

        // This helper resets the table so we are not showing old items by mistake.
        const clearResults = () => {
          allProducts = [];
          currentPage = 1;
          if (resultsBody) {
            resultsBody.innerHTML =
              '<tr><td colspan="4" class="results-empty">Results cleared. Run a new search to see recommendations.</td></tr>';
          }
          if (resultsSummaryText) {
            resultsSummaryText.textContent =
              "Results cleared. Enter a new search term, SKU ID, or upload an image to refresh.";
          }
          updatePagination();
          // Keep results section visible in STATE 2, just clear the data
        };

        // Prepare UI for a brand-new search request (clears table + pagination)
        const prepareResultsForNewSearch = () => {
          allProducts = [];
          currentPage = 1;
          if (resultsBody) {
            resultsBody.innerHTML =
              '<tr><td colspan="4" class="results-empty">Searching Miros for matching products...</td></tr>';
          }
          updatePagination();
        };

        // This helper builds the table rows so we can actually see the product cards.
        const renderResults = (items = []) => {
          if (!resultsBody) return;

          // If no items but we have allProducts, show empty message
          if (!items.length && allProducts.length === 0) {
            resultsBody.innerHTML =
              '<tr><td colspan="4" class="results-empty">No results found. Try a different URL, SKU, or product attribute.</td></tr>';
            summariseResults(0);
            return;
          }
          
          // If no items for current page but we have products, show message
          if (!items.length && allProducts.length > 0) {
            resultsBody.innerHTML =
              '<tr><td colspan="4" class="results-empty">No results found. Try a different URL, SKU, or product attribute.</td></tr>';
            summariseResults(allProducts.length);
            return;
          }

          const rows = items.map((item) => {
            const {
              productTitle = "-",
              optionId = "-",
              url = "",
              imageUrl = "",
            } = item;

            const productId = deriveProductIdFromSource(url, optionId);

            // Truncate URL to 20-25 characters
            let displayUrl = url;
            if (url && url.length > 25) {
              displayUrl = url.substring(0, 22) + '...';
            }
            const safeUrl = url
              ? `<a href="${url}" target="_blank" rel="noopener noreferrer" title="${url}">${displayUrl}</a>`
              : "-";

            const imageHtml = imageUrl
              ? `<img src="${imageUrl}" alt="${productTitle}" style="max-width: 100px; max-height: 100px; object-fit: contain;" />`
              : "-";

            return `
              <tr>
                <td>${imageHtml}</td>
                <td>${productTitle}</td>
                <td>${productId}</td>
                <td>${safeUrl}</td>
              </tr>
            `;
          });

          resultsBody.innerHTML = rows.join("");
          summariseResults(allProducts.length);
          
          // Results section already shown at start of search - just ensure it's visible
          if (!hasSearched) {
            showResultsSection();
          }
        };

        // Merge a batch of products into allProducts (dedup + optional reset)
        const appendUniqueProducts = (items = [], options = {}) => {
          const { reset = false, silent = false } = options;
          if (!Array.isArray(items)) return 0;
          
          const normalized = items
            .filter(Boolean)
            .map((item) => ({
              productTitle: item.productTitle || item.title || item.name || '-',
              optionId: item.optionId || item.option_id || item.itemId || item.item_id || '-',
              url: item.url || item.productUrl || item.product_url || item.uri || '',
              imageUrl: item.imageUrl || item.image_url || item.image || item.img || '',
            }));
          
          let baseList = reset ? [] : Array.isArray(allProducts) ? [...allProducts] : [];
          const seenKeys = new Set(
            baseList.map((item) => (item.url || item.optionId || '').toLowerCase())
          );
          const deduped = normalized.filter((item) => {
            const key = (item.url || item.optionId || '').toLowerCase();
            if (key && seenKeys.has(key)) {
              return false;
            }
            if (key) {
              seenKeys.add(key);
            }
            return !!(item.productTitle || item.url || item.optionId);
          });
          
          if (reset) {
            allProducts = deduped;
          } else if (deduped.length) {
            allProducts = [...baseList, ...deduped];
          }
          
          if (reset && deduped.length === 0) {
            allProducts = [];
          }
          
          currentPage = 1;
          updatePagination();
          renderResults(getCurrentPageItems());
          
          if (!silent) {
            if (allProducts.length >= TARGET_PRODUCT_COUNT) {
              closeMirosOverlay();
              showStatus(`Loaded ${allProducts.length} products successfully!`, "success");
              setTimeout(() => clearStatus(), 2000);
            } else {
              showStatus(
                `Loading ${TARGET_PRODUCT_COUNT} products... (${allProducts.length}/${TARGET_PRODUCT_COUNT})`,
                "pending"
              );
            }
          }
          
          return deduped.length;
        };

        // Miros API configuration - using Integration ID only (no API key)
        const MIROS_API_URL = 'https://api.miros.services/graphql';
        const MIROS_INTEGRATION_ID = 'fb97f7d4-fe95-402f-a81a-402cb062eaa3';
        const MIROS_SLOT = 1;
        const MIROS_API_KEY = '0ddbc6c416ae8f61af7079a7892592138e38b9ad5204cf4ec0682b0e8eea16fe';
        const TARGET_PRODUCT_COUNT = 100;

        // Direct API call to Miros GraphQL (no popup - fills table directly)
        async function callMirosAPI(query, variables) {
          try {
            const headers = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Integration-Id': MIROS_INTEGRATION_ID,
                'x-miros-integration': MIROS_INTEGRATION_ID,
              },
              body: JSON.stringify({ query, variables }),
            };
            if (MIROS_API_KEY) {
              headers.headers['x-api-key'] = MIROS_API_KEY;
              headers.headers['x-miros-key'] = MIROS_API_KEY;
            }
            const response = await fetch(MIROS_API_URL, headers);

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Miros API error (${response.status}): ${errorText}`);
            }

            const data = await response.json();

            if (data.errors) {
              // If we get authentication errors, user might need API key
              const authError = data.errors.find(e => 
                e.message?.toLowerCase().includes('auth') || 
                e.message?.toLowerCase().includes('unauthorized') ||
                e.message?.toLowerCase().includes('api key')
              );
              
              if (authError) {
                throw new Error('Authentication required. You may need to provide an API key in the request headers. Check Miros documentation for API authentication.');
              }
              
              // Log schema errors to help debug
              console.error('Miros GraphQL Schema Errors:', data.errors);
              throw new Error(`Miros API errors: ${JSON.stringify(data.errors)}`);
            }

            return data.data;
          } catch (error) {
            console.error('Error calling Miros API:', error);
            throw error;
          }
        }

        const SEARCH_ITEMS_QUERY = `
          query SearchItems($integration_id: ID!, $text_query: String!, $limit: Int!, $skip: Int!) {
            search(
              integration_id: $integration_id,
              text_query: $text_query,
              limit: $limit,
              skip: $skip
            ) {
              items {
                itemId
                alias
                title
                url
                imageUrl
              }
            }
          }
        `;

        async function fetchProductsViaAPI(rawValue) {
          if (!MIROS_API_KEY) return [];
          const searchText = rawValue?.trim();
          if (!searchText) return [];

          const aggregated = [];
          const seenKeys = new Set();
          const pageSize = 50;
          const maxPages = 5;
          let skip = 0;

          for (let page = 0; page < maxPages && aggregated.length < TARGET_PRODUCT_COUNT; page++) {
            const limit = Math.min(pageSize, TARGET_PRODUCT_COUNT - aggregated.length);
            try {
              const data = await callMirosAPI(SEARCH_ITEMS_QUERY, {
                integration_id: MIROS_INTEGRATION_ID,
                text_query: searchText,
                limit,
                skip,
              });

              const items = data?.search?.items || [];
              console.log(`Search query returned ${items.length} items (skip=${skip}, limit=${limit})`);

              if (!items.length) {
                break;
              }

              for (const item of items) {
                const normalized = transformMirosResult(item);
                const key = (normalized.url || normalized.optionId || '').toLowerCase();
                if (key && seenKeys.has(key)) continue;
                seenKeys.add(key);
                aggregated.push(normalized);
                if (aggregated.length >= TARGET_PRODUCT_COUNT) {
                  break;
                }
              }

              if (items.length < limit) {
                // No more pages available
                break;
              }

              skip += items.length;
            } catch (error) {
              console.error('Search API call failed:', error);
              break;
            }
          }

          console.log(`Total products fetched from search API: ${aggregated.length}`);
          return aggregated;
        }

        // Introspect GraphQL schema to find ALL available queries
        async function introspectMirosSchema() {
          // Get full schema - all types and queries
          const fullSchemaQuery = `
            query IntrospectFullSchema {
              __schema {
                queryType {
                  name
                  fields {
                    name
                    description
                    args {
                      name
                      description
                      type {
                        name
                        kind
                        ofType {
                          name
                          kind
                          inputFields {
                            name
                            type {
                              name
                              kind
                              ofType {
                                name
                                kind
                              }
                            }
                          }
                        }
                      }
                    }
                    type {
                      name
                      kind
                      ofType {
                        name
                        fields {
                          name
                          type {
                            name
                            kind
                            ofType {
                              name
                              kind
                            }
                          }
                        }
                      }
                    }
                  }
                }
                types {
                  name
                  kind
                }
              }
            }
          `;
          
          try {
            const schema = await callMirosAPI(fullSchemaQuery, {});
            
            console.log('=== FULL Miros GraphQL Schema ===');
            console.log('All Query fields:', schema.__schema?.queryType?.fields?.map(f => ({
              name: f.name,
              args: f.args?.map(a => ({ 
                name: a.name, 
                type: a.type?.ofType?.name || a.type?.name,
                inputFields: a.type?.ofType?.inputFields?.map(f => ({ name: f.name, type: f.type?.ofType?.name || f.type?.name }))
              })),
              returnType: f.type?.ofType?.name || f.type?.name,
              returnFields: f.type?.ofType?.fields?.map(f => f.name)
            })));
            console.log('All types:', schema.__schema?.types?.map(t => t.name).filter(Boolean));
            
            // Get AutocompleteSuggestionsPage type fields - THIS IS CRITICAL
            const autocompletePageType = schema.__schema?.queryType?.fields?.find(f => f.name === 'autocompleteSuggestionsPage');
            if (autocompletePageType) {
              const returnTypeName = autocompletePageType.type?.ofType?.name;
              console.log('=== AutocompleteSuggestionsPage Type ===');
              console.log('Return type:', returnTypeName);
              console.log('Available fields:', autocompletePageType.type?.ofType?.fields?.map(f => f.name));
              console.log('Query args:', autocompletePageType.args);
              if (autocompletePageType.args?.[2]?.type?.ofType?.inputFields) {
                console.log('AutocompleteSuggestionsQuery input fields:', autocompletePageType.args[2].type.ofType.inputFields.map(f => ({
                  name: f.name,
                  type: f.type?.ofType?.name || f.type?.name
                })));
              }
              
              // Store the actual available fields for later use
              autocompletePageType._actualFields = autocompletePageType.type?.ofType?.fields?.map(f => f.name) || [];
            }
            
            // Try to find item-related queries
            const itemQueries = schema.__schema?.queryType?.fields?.filter(f => 
              f.name?.toLowerCase().includes('item') || 
              f.name?.toLowerCase().includes('recommendation') ||
              f.name?.toLowerCase().includes('search') ||
              f.name?.toLowerCase().includes('suggestion')
            );
            console.log('Item/Recommendation/Search related queries:', itemQueries);
            
            return schema;
          } catch (error) {
            console.error('Failed to introspect schema:', error);
            return null;
          }
        }

        // Transform Miros result / scraped item to table format
        function transformMirosResult(item) {
          return {
            productTitle: item.productTitle || item.title || item.name || item.productTitle || '-',
            optionId: item.optionId || item.option_id || item.itemId || item.item_id || '-',
            url: item.url || item.productUrl || item.product_url || item.uri || '',
            imageUrl: item.imageUrl || item.image_url || item.image || item.img || '',
          };
        }

        // Scrape Miros overlay DOM and fill our table
        async function scrapeMirosOverlayIntoTable() {
          console.log('=== Starting Miros overlay scraping ===');
          
          // SIMPLIFIED: Find the overlay/modal directly
          let container = null;
          
          // Method 1: Look for visible dialog/modal (most common)
          const visibleDialogs = Array.from(document.querySelectorAll('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]'))
            .filter(d => {
              // CRITICAL: Exclude our own focus overlay
              if (d.id === 'focusOverlay' || d.classList.contains('focus-overlay')) {
                return false;
              }
              const style = window.getComputedStyle(d);
              return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
            });
          
          if (visibleDialogs.length > 0) {
            // Prefer dialogs that contain Miros elements or product links
            const mirosDialog = visibleDialogs.find(d => 
              d.querySelector('[id*="miros"], [class*="miros"], [data-miros], a[href*="/p/"]')
            );
            container = mirosDialog || visibleDialogs[0];
            console.log('Found visible dialog/modal:', container.id || container.className);
          }
          
          // Method 2: Look for Miros-specific containers
          if (!container) {
            const mirosContainers = [
              '#miros-recommendations',
              '[id*="miros-recommendations"]',
              '[id*="miros"][id*="overlay"]',
              '[id*="miros"][id*="modal"]',
              '[class*="miros-overlay"]',
              '[class*="miros-modal"]',
            ];
            
            for (const selector of mirosContainers) {
              const elements = document.querySelectorAll(selector);
              for (const el of elements) {
                // Exclude our own elements
                if (el.id === 'focusOverlay' || el.classList.contains('focus-overlay')) continue;
                
                const style = window.getComputedStyle(el);
                if (style.display !== 'none' && style.visibility !== 'hidden') {
                  // Check if it has product links or Miros content
                  if (el.querySelector('a[href*="/p/"], [id*="miros"], [class*="miros"]')) {
                container = el;
                    console.log('Found Miros container with content:', selector);
                break;
              }
                }
              }
              if (container) break;
            }
          }
          
          // Method 3: Look for dialogs/modals that contain product links
          if (!container) {
            const allDialogs = document.querySelectorAll('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]');
            for (const dialog of allDialogs) {
              // Exclude our focus overlay
              if (dialog.id === 'focusOverlay' || dialog.classList.contains('focus-overlay')) continue;
              
              const style = window.getComputedStyle(dialog);
              if (style.display !== 'none' && style.visibility !== 'hidden') {
                // Check if it has product links
                const hasProductLinks = dialog.querySelector('a[href*="/p/"]');
                if (hasProductLinks) {
                  container = dialog;
                  console.log('Found dialog with product links:', dialog.id || dialog.className);
                  break;
                }
              }
            }
          }
          
          // Method 4: Fallback to body
          if (!container) {
            container = document.body;
            console.log('Using document.body as container');
          }

          // SIMPLIFIED: Find product images (they're the most reliable indicator)
          const allImages = container.querySelectorAll('img[src]');
          console.log(`Found ${allImages.length} images in container`);
          
          // Filter to product images (exclude logos, icons, small images)
          const productImages = Array.from(allImages).filter(img => {
            const src = img.src || img.getAttribute('src') || '';
            const alt = img.alt || '';
            const width = img.naturalWidth || img.width || 0;
            const height = img.naturalHeight || img.height || 0;
            
            // Exclude very small images (likely icons)
            if (width > 0 && width < 100) return false;
            if (height > 0 && height < 100) return false;
            
            // Exclude logos and icons
            if (alt.toLowerCase().includes('logo') || alt.toLowerCase().includes('icon')) return false;
            if (src.includes('logo') || src.includes('icon')) return false;
            
            // Must be in a card-like container or have meaningful parent
            const parent = img.closest('[role="listitem"], [class*="card"], [class*="item"], a');
            if (!parent) return false;
            
            // Must have some text nearby (product title)
            const hasText = parent.textContent && parent.textContent.trim().length > 10;
            
            return hasText;
          });
          
          console.log(`Filtered to ${productImages.length} product images`);
          
          if (productImages.length === 0) {
            console.warn('No product images found. Trying to find product links directly...');
            // Fallback: try to find product links
            const productLinks = container.querySelectorAll('a[href*="/p/"]');
            const validLinks = Array.from(productLinks).filter(link => {
              const href = link.href || link.getAttribute('href') || '';
              return href.includes('/p/') && href.includes('centrepointstores.com');
            });
            
            if (validLinks.length > 0) {
              console.log(`Found ${validLinks.length} product links, using those`);
              
              // Sort links by visual position (top to bottom, left to right)
              const sortedLinks = Array.from(validLinks).sort((a, b) => {
                const rectA = a.getBoundingClientRect();
                const rectB = b.getBoundingClientRect();
                const topDiff = rectA.top - rectB.top;
                if (Math.abs(topDiff) > 50) {
                  return topDiff;
                }
                return rectA.left - rectB.left;
              });
              
              // Convert links to "cards" for processing
              const items = sortedLinks.map(link => {
                const img = link.querySelector('img[src]');
                const text = link.textContent?.trim() || img?.alt || '';
                const url = link.href || link.getAttribute('href') || '';
                const imageUrl = img ? (img.src || img.getAttribute('src') || '') : '';
                const match = url.match(/\/p\/([^?]+)/);
                const optionId = match ? match[1] : '-';
                
                return {
                  productTitle: text.length > 10 ? text.substring(0, 150) : 'Product',
                  optionId: optionId,
                  url: url,
                  imageUrl: imageUrl,
                };
              });
              
              // Store all products and initialize pagination
              allProducts = items;
              currentPage = 1;
              updatePagination();
              renderResults(getCurrentPageItems());
              return items.length > 0;
            }
            
            console.error('No products found at all. Container:', container.id || container.className);
            // Show empty results
            renderResults([]);
            return false;
          }

          console.log(`Processing ${productImages.length} product cards`);
          
          // Sort product images by visual position (top to bottom, left to right)
          const sortedImages = Array.from(productImages).sort((a, b) => {
            const rectA = a.getBoundingClientRect();
            const rectB = b.getBoundingClientRect();
            // First sort by top position (y-coordinate)
            const topDiff = rectA.top - rectB.top;
            if (Math.abs(topDiff) > 50) { // If difference is significant (different row)
              return topDiff;
            }
            // If in same row, sort by left position (x-coordinate)
            return rectA.left - rectB.left;
          });
          
          // Helper function to extract URL from modal after clicking (async)
          const extractUrlFromModal = async (card, productContainer) => {
            return new Promise((resolve) => {
              // Try clicking the card to open modal
              try {
                card.click();
                
                // Wait for modal to appear
                setTimeout(() => {
                  // Look for "View details" button in modal
                  const modal = document.querySelector('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]');
                  if (modal) {
                    const viewDetailsBtn = Array.from(modal.querySelectorAll('button, a')).find(btn => {
                      const text = btn.textContent?.toLowerCase() || '';
                      return text.includes('view details');
                    });
                    
                    if (viewDetailsBtn) {
                      const url = viewDetailsBtn.href || 
                                 viewDetailsBtn.getAttribute('href') ||
                                 viewDetailsBtn.getAttribute('data-href') ||
                                 '';
                      if (url && url.includes('/p/')) {
                        // Close modal
                        const closeBtn = modal.querySelector('[aria-label*="close" i], [class*="close"], button[aria-label*="×"]');
                        if (closeBtn) closeBtn.click();
                        resolve(url);
                        return;
                      }
                    }
                    
                    // Close modal if we opened it
                    const closeBtn = modal.querySelector('[aria-label*="close" i], [class*="close"], button[aria-label*="×"]');
                    if (closeBtn) closeBtn.click();
                  }
                  resolve('');
                }, 500);
              } catch (e) {
                resolve('');
              }
            });
          };

          // Extract data from product images (using sorted order)
          const items = sortedImages.map((productImg, index) => {
            // Find the card container (parent with the most info)
            const card = productImg.closest('[role="listitem"], [class*="card"], [class*="item"], a') || productImg.parentElement;
            // Find the actual product container
            let productContainer = card.closest('[role="listitem"], [class*="card"], [class*="item"]') || card;
            
            // Use the product image we already found
            const img = productImg;
            const imageUrl = img.src || img.getAttribute('src') || '';
            
            // Find product title element (the red highlighted box)
            // Try common title selectors - look for the main text in the card
            let titleEl = null;
            const titleSelectors = [
              'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
              '[class*="title"]',
              '[class*="product-title"]',
              '[class*="name"]',
              '[data-title]',
              'p[class*="title"]',
              'span[class*="title"]',
              'div[class*="title"]'
            ];
            
            for (const selector of titleSelectors) {
              titleEl = productContainer.querySelector(selector) || card.querySelector(selector);
              if (titleEl && titleEl.textContent && titleEl.textContent.trim().length > 10) {
                break;
              }
            }
            
            // If no title element found, look for the longest text node that's not price/brand/button text
            if (!titleEl || !titleEl.textContent || titleEl.textContent.trim().length < 10) {
              const allTextElements = productContainer.querySelectorAll('p, span, div, a, h1, h2, h3, h4, h5, h6');
              let longestText = '';
              for (const el of allTextElements) {
                const text = el.textContent?.trim() || '';
                // Skip if it's too short, is a price (AED/$, numbers), or is button text
                if (text.length > longestText.length && 
                    text.length > 10 && 
                    text.length < 200 &&
                    !text.match(/^AED\s*\d+/) &&
                    !text.match(/^\$\d+/) &&
                    !text.match(/^\d+$/) &&
                    !text.toLowerCase().includes('view details') &&
                    !text.toLowerCase().includes('add to') &&
                    !text.toLowerCase().includes('basket') &&
                    !text.toLowerCase().includes('cart')) {
                  longestText = text;
                  titleEl = el;
                }
              }
            }
            
            // Extract product title from title element
            let productTitle = '-';
            if (titleEl && titleEl.textContent) {
              productTitle = titleEl.textContent.trim();
              // Clean up title - remove price, brand prefixes if they're in the same text
              productTitle = productTitle
                .replace(/AED\s*\d+.*$/i, '')
                .replace(/^\$\d+.*$/i, '')
                .replace(/^\d+.*$/i, '')
                .trim();
            }
            
            // Fallback to image alt text
            if ((productTitle === '-' || productTitle.length < 10) && img) {
              const alt = img.getAttribute('alt') || '';
              if (alt && alt.length > 10) {
                productTitle = alt.trim();
              }
            }
            
            // Find product URL - look for "View details" link or product link
            let url = '';
            
            // Method 1: Look for buttons/links with "View details" text (case insensitive)
            const allButtons = productContainer.querySelectorAll('button, a');
            for (const btn of allButtons) {
              const text = btn.textContent?.toLowerCase() || '';
              if (text.includes('view details') || text.includes('view') && text.includes('details')) {
                url = btn.href || 
                      btn.getAttribute('href') ||
                      btn.getAttribute('data-href') ||
                      btn.getAttribute('onclick')?.match(/href['"]?\s*[:=]\s*['"]([^'"]+)/)?.[1] ||
                      '';
                if (url && url.includes('/p/')) {
                  break;
                }
              }
            }
            
            // Method 2: Look for any link/button with /p/ pattern in the card
            if (!url || !url.includes('/p/')) {
              const viewDetailsLink = productContainer.querySelector('a[href*="/p/"], button[data-href*="/p/"], a[href*="centrepointstores.com"][href*="/p/"]') ||
                                     card.querySelector('a[href*="/p/"], button[data-href*="/p/"]');
              
              if (viewDetailsLink) {
                url = viewDetailsLink.href || 
                      viewDetailsLink.getAttribute('href') ||
                      viewDetailsLink.getAttribute('data-href') ||
                      '';
              }
            }
            
            // Method 3: Check if card itself is a link or has data-url
            if (!url || !url.includes('/p/')) {
              if (card.tagName === 'A' && card.href && card.href.includes('/p/')) {
                url = card.href;
              } else {
                url = card.getAttribute('href') ||
                      card.getAttribute('data-url') ||
                      card.getAttribute('data-href') ||
                      card.getAttribute('data-product-url') ||
                      productContainer.getAttribute('href') ||
                      productContainer.getAttribute('data-url') ||
                      productContainer.getAttribute('data-href') ||
                      productContainer.getAttribute('data-product-url') ||
                      '';
              }
            }
            
            // Method 4: Look for any link in the container with /p/ pattern
            if (!url || !url.includes('/p/')) {
              const allLinks = productContainer.querySelectorAll('a[href]');
              for (const link of allLinks) {
                const href = link.href || link.getAttribute('href') || '';
                if (href.includes('/p/') && href.includes('centrepointstores.com')) {
                  url = href;
                  break;
                }
              }
            }
            
            // Method 5: Check data attributes for product ID and construct URL
            if (!url || !url.includes('/p/')) {
              const productId = card.getAttribute('data-product-id') ||
                               card.getAttribute('data-item-id') ||
                               card.getAttribute('miros-data-id') ||
                               card.getAttribute('data-id') ||
                               productContainer.getAttribute('data-product-id') ||
                               productContainer.getAttribute('data-item-id') ||
                               productContainer.getAttribute('data-id');
              
              if (productId && productId.match(/^\d+$/)) {
                url = `https://www.centrepointstores.com/ae/en/p/${productId}`;
              }
            }
            
            // Method 6: If still no URL, check if clicking is needed (but don't auto-click all at once - too disruptive)
            // This will be handled separately if needed - for now, we'll extract what we can without clicking
            
            // Extract product ID from URL (/p/... format - can be numeric, alphanumeric, or mixed)
            let optionId = '-';
            if (url && url.includes('/p/')) {
              const match = url.match(/\/p\/([^?]+)/);
              if (match && match[1]) {
                optionId = match[1];
              }
            }
            
            // Try other ID sources if URL didn't work
            if (optionId === '-') {
              optionId = card.getAttribute('miros-data-id') || 
                        card.getAttribute('data-miros-id') ||
                        card.getAttribute('data-item-id') ||
                        productContainer.getAttribute('miros-data-id') ||
                        productContainer.getAttribute('data-miros-id') ||
                        productContainer.getAttribute('data-item-id') ||
                        '';
              
              // Exclude layout IDs
              if (optionId && (optionId.includes('masonry') || optionId.includes('container') || optionId.includes('wrapper'))) {
                optionId = '-';
              }
            }

            // Extract category info
            const superCategory = 
              card.getAttribute('data-category') || 
              productContainer.getAttribute('data-category') ||
              card.getAttribute('data-miros-category') ||
              '-';
            
            const department = 
              card.getAttribute('data-department') || 
              productContainer.getAttribute('data-department') ||
              '-';

            // Log what we extracted for debugging
            if (index < 3) {
              console.log(`Product ${index + 1}:`, {
                title: productTitle,
                titleElement: titleEl?.tagName || 'none',
                titleText: titleEl?.textContent?.substring(0, 50) || 'none',
                optionId: optionId,
                url: url,
                hasImg: !!img,
                imgSrc: img?.src?.substring(0, 50) || 'none'
              });
            }

            return {
              productTitle: productTitle || `Product ${index + 1}`,
              optionId: optionId || `${index + 1}`,
              url: url || '-',
              imageUrl: imageUrl || '',
            };
          });

          console.log('Scraped items from Miros overlay:', items);
          
          appendUniqueProducts(items, { reset: allProducts.length === 0, silent: true });
          
          // Enhanced scrolling to fetch 100+ items
          if (allProducts.length < TARGET_PRODUCT_COUNT) {
            const targetItems = TARGET_PRODUCT_COUNT;
            const maxScrollAttempts = 25; // Maximum scroll attempts
            let scrollAttempts = 0;
            const scrollDelay = 2000; // Wait 2 seconds between scrolls
            let isScrolling = false;
            
            // Find the scrollable container with better detection
            const findScrollableContainer = () => {
              // Try multiple selectors for scrollable containers
              const selectors = [
                '[style*="overflow"]',
                '[class*="scroll"]',
                '[class*="grid"]',
                '[class*="masonry"]',
                '[class*="list"]',
                '[class*="container"]',
                '[data-scroll]'
              ];
              
              for (const selector of selectors) {
                const elements = container.querySelectorAll(selector);
                for (const el of elements) {
                  const style = window.getComputedStyle(el);
                  if (el.scrollHeight > el.clientHeight && 
                      (style.overflow === 'auto' || style.overflow === 'scroll' || 
                       style.overflowY === 'auto' || style.overflowY === 'scroll' ||
                       style.overflowX === 'auto' || style.overflowX === 'scroll')) {
                    return el;
                  }
                }
              }
              
              // Fallback: check container itself and parent elements
              let current = container;
              for (let i = 0; i < 5 && current; i++) {
                if (current.scrollHeight > current.clientHeight) {
                  return current;
                }
                current = current.parentElement;
              }
              
            return null;
            };
            
            const scrollableContainer = findScrollableContainer();
            
            if (scrollableContainer) {
              console.log('Found scrollable container, attempting to load 100+ items...');
              console.log('Container dimensions:', {
                scrollHeight: scrollableContainer.scrollHeight,
                clientHeight: scrollableContainer.clientHeight,
                scrollTop: scrollableContainer.scrollTop
              });
              
              // Function to extract ALL products from DOM (search entire container, not just scrollableContainer)
              const extractAllProductsFromDOM = () => {
                // Search in the entire container to find all products
                const allImages = container.querySelectorAll('img[src]');
                console.log(`Found ${allImages.length} total images in container`);
                
                const allProductImages = Array.from(allImages).filter(img => {
                  const src = img.src || img.getAttribute('src') || '';
                  const alt = img.alt || '';
                  const width = img.naturalWidth || img.width || 0;
                  const height = img.naturalHeight || img.height || 0;
                  
                  if (width > 0 && width < 100) return false;
                  if (height > 0 && height < 100) return false;
                  if (alt.toLowerCase().includes('logo') || alt.toLowerCase().includes('icon')) return false;
                  if (src.includes('logo') || src.includes('icon')) return false;
                  
                  const parent = img.closest('[role="listitem"], [class*="card"], [class*="item"], a');
                  if (!parent) return false;
                  
                  const hasText = parent.textContent && parent.textContent.trim().length > 10;
                  return hasText;
                });
                
                console.log(`Filtered to ${allProductImages.length} product images`);
                
                // Sort by visual position
                const sortedImages = Array.from(allProductImages).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  const topDiff = rectA.top - rectB.top;
                  if (Math.abs(topDiff) > 50) return topDiff;
                  return rectA.left - rectB.left;
                });
                
                // Extract ALL product data (we'll filter duplicates later)
                const allItems = sortedImages.map((productImg) => {
                  const card = productImg.closest('[role="listitem"], [class*="card"], [class*="item"], a') || productImg.parentElement;
                  const productContainer = card.closest('[role="listitem"], [class*="card"], [class*="item"]') || card;
                  const img = productImg;
                  const imageUrl = img.src || img.getAttribute('src') || '';
                  
                  const titleEl = productContainer.querySelector('h1, h2, h3, h4, h5, h6, [class*="title"], [class*="name"]') || 
                                 Array.from(productContainer.querySelectorAll('p, span, div')).find(el => {
                                   const text = el.textContent?.trim() || '';
                                   return text.length > 10 && text.length < 200 && !text.match(/^AED\s*\d+/) && !text.match(/^\$\d+/);
                                 });
                  const productTitle = titleEl?.textContent?.trim() || img.getAttribute('alt') || '-';
                  
                  const linkEl = productContainer.querySelector('a[href*="/p/"]') || card.querySelector('a[href*="/p/"]');
                  const url = linkEl?.href || linkEl?.getAttribute('href') || '';
                  
                  if (!url || url === '-' || !url.includes('/p/')) return null;
                  
                  const match = url.match(/\/p\/([^?]+)/);
                  const optionId = match ? match[1] : '-';
                  
                  return {
                    productTitle: productTitle || `Product`,
                    optionId: optionId,
                    url: url,
                    imageUrl: imageUrl || '',
                  };
                }).filter(item => item !== null && item.url !== '-');
                
                // Filter duplicates by URL to get unique items
                const uniqueItems = [];
                const seenUrls = new Set();
                for (const item of allItems) {
                  if (!seenUrls.has(item.url)) {
                    seenUrls.add(item.url);
                    uniqueItems.push(item);
                  }
                }
                
                console.log(`Extracted ${uniqueItems.length} unique products from DOM`);
                return uniqueItems;
              };
              
              // Function to update products list with all extracted items (NO UI UPDATE - just store data)
              const updateProductsList = () => {
                const allExtracted = extractAllProductsFromDOM();
                
                if (allExtracted.length > allProducts.length) {
                  allProducts = allExtracted; // Replace with all items (no duplicates)
                  console.log(`✅ Updated: Total products now: ${allProducts.length}`);
                  
                  // Show progress in status message only (NO table update until done)
                  showStatus(`Fetching products from overlay... (${allProducts.length}/${targetItems} products fetched)`, "pending");
                  
                  return true;
                } else if (allExtracted.length === allProducts.length) {
                  console.log(`No new items found. Current total: ${allProducts.length}`);
                  return false;
                }
                
                return false;
              };
              
              // Function to show loading state in table
              const showLoadingInTable = () => {
                const resultsBody = document.getElementById('resultsBody');
                if (resultsBody) {
                  resultsBody.innerHTML = `<tr><td colspan="4" class="results-empty" style="text-align: center; padding: 40px;">
                    <div style="font-size: 16px; color: var(--text-secondary); margin-bottom: 10px;">
                      Loading products from overlay...
                    </div>
                    <div style="font-size: 14px; color: var(--text-muted);">
                      ${allProducts.length}/${targetItems} products fetched
                    </div>
                  </td></tr>`;
                }
              };
              
              // Use MutationObserver to detect when new items are loaded
              const observer = new MutationObserver((mutations) => {
                if (isScrolling) return; // Prevent concurrent processing
                
                const hasNewContent = mutations.some(mutation => {
                  return mutation.addedNodes.length > 0;
                });
                
                if (hasNewContent) {
                  // Wait a bit for content to fully render
                  setTimeout(() => {
                    updateProductsList();
                    showLoadingInTable(); // Update loading message
                    isScrolling = false;
                  }, 1000);
                }
              });
              
              // Start observing both scrollableContainer and container
              observer.observe(scrollableContainer, {
                childList: true,
                subtree: true
              });
              observer.observe(container, {
                childList: true,
                subtree: true
              });
              
              // Show loading state in table immediately
              showLoadingInTable();
              
              // Start scrolling process
              const scrollInterval = setInterval(() => {
                // Check if we've reached our goal or max attempts
                if (allProducts.length >= targetItems) {
                  clearInterval(scrollInterval);
                  observer.disconnect();
                  console.log(`✅ Target reached! Total items: ${allProducts.length}`);
                  
                  // Final update to ensure all items are captured
                  updateProductsList();
                  
                  // NOW update UI with all products
                  currentPage = 1;
                  updatePagination();
                  renderResults(getCurrentPageItems());
                  
                  // Close overlay after scraping is complete
                  setTimeout(() => {
                    closeMirosOverlay();
                    showStatus(`Successfully loaded ${allProducts.length} products!`, "success");
                    setTimeout(() => clearStatus(), 2000);
                  }, 500);
                  
                  return;
                }
                
                if (scrollAttempts >= maxScrollAttempts) {
                  clearInterval(scrollInterval);
                  observer.disconnect();
                  console.log(`⚠️ Max attempts reached. Total items: ${allProducts.length}`);
                  
                  // Final extraction
                  updateProductsList();
                  
                  // NOW update UI with all products we found
                  currentPage = 1;
                  updatePagination();
                  renderResults(getCurrentPageItems());
                  
                  // Close overlay
                  setTimeout(() => {
                    closeMirosOverlay();
                    showStatus(`Loaded ${allProducts.length} products (max attempts reached)`, "info");
                    setTimeout(() => clearStatus(), 2000);
                  }, 500);
                  
                  return;
                }
                
                if (isScrolling) return; // Skip if already processing
                isScrolling = true;
                
                const previousScrollTop = scrollableContainer.scrollTop;
                const previousScrollHeight = scrollableContainer.scrollHeight;
                
                // Scroll to bottom
                scrollableContainer.scrollTop = scrollableContainer.scrollHeight;
                scrollAttempts++;
                
                // Update status and loading table
                showStatus(`Fetching products from overlay... (${allProducts.length}/${targetItems} products fetched)`, "pending");
                showLoadingInTable();
                
                console.log(`📜 Scroll attempt ${scrollAttempts}/${maxScrollAttempts}, current items: ${allProducts.length}`);
                
                // Check if we've reached the end (scroll position didn't change)
                setTimeout(() => {
                  const newScrollHeight = scrollableContainer.scrollHeight;
                  const newScrollTop = scrollableContainer.scrollTop;
                  
                  if (newScrollTop === previousScrollTop && newScrollHeight === previousScrollHeight) {
                    // Reached end - do final extraction
                    console.log('⚠️ Reached end of scrollable content');
                    updateProductsList();
                    isScrolling = false;
                    
                    // If we still don't have 100, try one more aggressive extraction
                    if (allProducts.length < targetItems) {
                      console.log('Trying one more extraction pass...');
                      setTimeout(() => {
                        updateProductsList();
                        
                        // NOW update UI with all products
                        currentPage = 1;
                        updatePagination();
                        renderResults(getCurrentPageItems());
                        
                        setTimeout(() => {
                          closeMirosOverlay();
                          showStatus(`Loaded ${allProducts.length} products successfully!`, "success");
                          setTimeout(() => clearStatus(), 2000);
                        }, 500);
                      }, 1500);
                    } else {
                      // We have 100+, update UI now
                      currentPage = 1;
                      updatePagination();
                      renderResults(getCurrentPageItems());
                      
                      setTimeout(() => {
                        closeMirosOverlay();
                        showStatus(`Successfully loaded ${allProducts.length} products!`, "success");
                        setTimeout(() => clearStatus(), 2000);
                      }, 500);
                    }
                  } else {
                    // New content might be loading, extract after delay
                    setTimeout(() => {
                      updateProductsList();
                      showLoadingInTable(); // Update loading message
                      isScrolling = false;
                    }, 1500);
                  }
                }, 800);
              }, scrollDelay);
              
              // Initial extraction and first scroll
              setTimeout(() => {
                // Do initial extraction
                updateProductsList();
                showLoadingInTable();
                
                // Then scroll
                scrollableContainer.scrollTop = scrollableContainer.scrollHeight;
                
                // Extract again after scroll
                setTimeout(() => {
                  updateProductsList();
                  showLoadingInTable();
                }, 2000);
              }, 1000);
              
            } else {
              console.warn('No scrollable container found. Attempting to extract all items from container...');
              
              // Show loading state
              const resultsBody = document.getElementById('resultsBody');
              if (resultsBody) {
                resultsBody.innerHTML = `<tr><td colspan="4" class="results-empty" style="text-align: center; padding: 40px;">
                  <div style="font-size: 16px; color: var(--text-secondary); margin-bottom: 10px;">
                    Loading products from overlay...
                  </div>
                  <div style="font-size: 14px; color: var(--text-muted);">
                    ${allProducts.length}/${targetItems} products fetched
                  </div>
                </td></tr>`;
              }
              
              // Still try to extract all products from the container
              const extractAllProductsFromDOM = () => {
                const allImages = container.querySelectorAll('img[src]');
                console.log(`Found ${allImages.length} total images in container`);
                
                const allProductImages = Array.from(allImages).filter(img => {
                  const src = img.src || img.getAttribute('src') || '';
                  const alt = img.alt || '';
                  const width = img.naturalWidth || img.width || 0;
                  const height = img.naturalHeight || img.height || 0;
                  
                  if (width > 0 && width < 100) return false;
                  if (height > 0 && height < 100) return false;
                  if (alt.toLowerCase().includes('logo') || alt.toLowerCase().includes('icon')) return false;
                  if (src.includes('logo') || src.includes('icon')) return false;
                  
                  const parent = img.closest('[role="listitem"], [class*="card"], [class*="item"], a');
                  if (!parent) return false;
                  
                  const hasText = parent.textContent && parent.textContent.trim().length > 10;
                  return hasText;
                });
                
                const sortedImages = Array.from(allProductImages).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  const topDiff = rectA.top - rectB.top;
                  if (Math.abs(topDiff) > 50) return topDiff;
                  return rectA.left - rectB.left;
                });
                
                const allItems = sortedImages.map((productImg) => {
                  const card = productImg.closest('[role="listitem"], [class*="card"], [class*="item"], a') || productImg.parentElement;
                  const productContainer = card.closest('[role="listitem"], [class*="card"], [class*="item"]') || card;
                  const img = productImg;
                  const imageUrl = img.src || img.getAttribute('src') || '';
                  
                  const titleEl = productContainer.querySelector('h1, h2, h3, h4, h5, h6, [class*="title"], [class*="name"]') || 
                                 Array.from(productContainer.querySelectorAll('p, span, div')).find(el => {
                                   const text = el.textContent?.trim() || '';
                                   return text.length > 10 && text.length < 200 && !text.match(/^AED\s*\d+/) && !text.match(/^\$\d+/);
                                 });
                  const productTitle = titleEl?.textContent?.trim() || img.getAttribute('alt') || '-';
                  
                  const linkEl = productContainer.querySelector('a[href*="/p/"]') || card.querySelector('a[href*="/p/"]');
                  const url = linkEl?.href || linkEl?.getAttribute('href') || '';
                  
                  if (!url || url === '-' || !url.includes('/p/')) return null;
                  
                  const match = url.match(/\/p\/([^?]+)/);
                  const optionId = match ? match[1] : '-';
                  
                  return {
                    productTitle: productTitle || `Product`,
                    optionId: optionId,
                    url: url,
                    imageUrl: imageUrl || '',
                  };
                }).filter(item => item !== null && item.url !== '-');
                
                const uniqueItems = [];
                const seenUrls = new Set();
                for (const item of allItems) {
                  if (!seenUrls.has(item.url)) {
                    seenUrls.add(item.url);
                    uniqueItems.push(item);
                  }
                }
                
                console.log(`Extracted ${uniqueItems.length} unique products from container`);
                return uniqueItems;
              };
              
              // Try multiple times to extract all products
              let extractionAttempts = 0;
              const maxExtractionAttempts = 5;
              const extractionInterval = setInterval(() => {
                extractionAttempts++;
                const allExtracted = extractAllProductsFromDOM();
                
                if (allExtracted.length > allProducts.length) {
                  allProducts = allExtracted;
                  console.log(`Updated products: ${allProducts.length}`);
                  
                  // Update loading message
                  showStatus(`Fetching products from overlay... (${allProducts.length}/${targetItems} products fetched)`, "pending");
                  if (resultsBody) {
                    resultsBody.innerHTML = `<tr><td colspan="4" class="results-empty" style="text-align: center; padding: 40px;">
                      <div style="font-size: 16px; color: var(--text-secondary); margin-bottom: 10px;">
                        Loading products from overlay...
                      </div>
                      <div style="font-size: 14px; color: var(--text-muted);">
                        ${allProducts.length}/${targetItems} products fetched
                      </div>
                    </td></tr>`;
                  }
                }
                
                if (allProducts.length >= targetItems || extractionAttempts >= maxExtractionAttempts) {
                  clearInterval(extractionInterval);
                  
                  // NOW update UI with all products
                  currentPage = 1;
                  updatePagination();
                  renderResults(getCurrentPageItems());
                  
                  setTimeout(() => {
                    closeMirosOverlay();
                    showStatus(`Successfully loaded ${allProducts.length} products!`, "success");
                    setTimeout(() => clearStatus(), 2000);
                  }, 500);
                }
              }, 2000);
            }
          } else {
            // If we already have 100+ items, render immediately and close overlay
            currentPage = 1;
            updatePagination();
            renderResults(getCurrentPageItems());
            
            setTimeout(() => {
              closeMirosOverlay();
              showStatus(`Successfully loaded ${allProducts.length} products!`, "success");
              setTimeout(() => clearStatus(), 2000);
            }, 500);
          }
          
          // Only initialize pagination if we're not fetching (already have 100+)
          // Otherwise, pagination will be initialized after fetching completes
          if (items.length >= 100) {
            currentPage = 1;
            updatePagination();
          }
          
          return items.length > 0;
        }
        
        // Get items for current page
        function getCurrentPageItems() {
          const startIndex = (currentPage - 1) * itemsPerPage;
          const endIndex = startIndex + itemsPerPage;
          return allProducts.slice(startIndex, endIndex);
        }
        
        // Update pagination UI
        function updatePagination() {
          const paginationContainer = document.getElementById('paginationContainer');
          if (!paginationContainer) return;
          
          const totalPages = Math.ceil(allProducts.length / itemsPerPage);
          
          if (totalPages <= 1) {
            paginationContainer.innerHTML = '';
            return;
          }
          
          let paginationHTML = '<div class="pagination">';
          
          // Previous button
          if (currentPage > 1) {
            paginationHTML += `<button class="pagination__button" onclick="goToPage(${currentPage - 1})" aria-label="Previous page">‹</button>`;
          } else {
            paginationHTML += `<button class="pagination__button pagination__button--disabled" disabled aria-label="Previous page">‹</button>`;
          }
          
          // Page numbers
          const maxVisiblePages = 5;
          let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
          let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
          
          if (endPage - startPage < maxVisiblePages - 1) {
            startPage = Math.max(1, endPage - maxVisiblePages + 1);
          }
          
          if (startPage > 1) {
            paginationHTML += `<button class="pagination__button" onclick="goToPage(1)">1</button>`;
            if (startPage > 2) {
              paginationHTML += `<span class="pagination__ellipsis">...</span>`;
            }
          }
          
          for (let i = startPage; i <= endPage; i++) {
            if (i === currentPage) {
              paginationHTML += `<button class="pagination__button pagination__button--active">${i}</button>`;
            } else {
              paginationHTML += `<button class="pagination__button" onclick="goToPage(${i})">${i}</button>`;
            }
          }
          
          if (endPage < totalPages) {
            if (endPage < totalPages - 1) {
              paginationHTML += `<span class="pagination__ellipsis">...</span>`;
            }
            paginationHTML += `<button class="pagination__button" onclick="goToPage(${totalPages})">${totalPages}</button>`;
          }
          
          // Next button
          if (currentPage < totalPages) {
            paginationHTML += `<button class="pagination__button" onclick="goToPage(${currentPage + 1})" aria-label="Next page">›</button>`;
          } else {
            paginationHTML += `<button class="pagination__button pagination__button--disabled" disabled aria-label="Next page">›</button>`;
          }
          
          paginationHTML += `<span class="pagination__info">Page ${currentPage} of ${totalPages} (${allProducts.length} items)</span>`;
          paginationHTML += '</div>';
          
          paginationContainer.innerHTML = paginationHTML;
        }
        
        // Go to specific page
        function goToPage(page) {
          const totalPages = Math.ceil(allProducts.length / itemsPerPage);
          if (page < 1 || page > totalPages) return;
          
          currentPage = page;
          updatePagination();
          renderResults(getCurrentPageItems());
          
          // Scroll to top of results
          const resultsSection = document.getElementById('dashboardResults');
          if (resultsSection) {
            resultsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
          }
        }
        
        // Make goToPage available globally
        window.goToPage = goToPage;

        // Fetch results directly from Miros API (no popup)
        async function fetchMirosResultsDirectly(type, options) {
          const { url, itemId, query, category, limit = 15 } = options;
          let mirosData = [];

          // First, introspect schema to find available queries
          const schema = await introspectMirosSchema();
          const availableQueries = schema?.__schema?.queryType?.fields || [];

          if (type === 'url') {
            // Extract product name from URL for text search
            // URL format: .../SPLASH-Striped-Sleeveless-Polo-Dress/p/1025360
            // Extract the product name part before /p/
            let urlQuery = url.split('/p/')[0].split('/').pop().replace(/-/g, ' ');
            console.log('Extracted product name from URL for search:', urlQuery);

            // Use autocompleteSuggestionsPage for URL-based search
            const searchQuery = availableQueries.find(q => 
              q.name === 'autocompleteSuggestionsPage'
            );

            if (!searchQuery) {
              throw new Error('Autocomplete suggestions query not available');
            }

            const queryName = searchQuery.name;
            const queryArg = searchQuery.args?.find(a => a.name === 'query');
            const isInputObject = queryArg?.type?.ofType?.name === 'AutocompleteSuggestionsQuery';
            
            // Get actual fields available on AutocompleteSuggestionsPage
            const returnType = searchQuery.type?.ofType;
            const availableFields = returnType?.fields?.map(f => f.name) || [];
            console.log('AutocompleteSuggestionsPage available fields:', availableFields);
            
            // Build query dynamically based on what fields actually exist
            let fieldsToQuery = '';
            
            // Common patterns - try to find which one exists
            if (availableFields.includes('edges')) {
              fieldsToQuery = `
                edges {
                  node {
                    itemId
                    title
                    url
                    imageUrl
                  }
                }
              `;
            } else if (availableFields.includes('items')) {
              fieldsToQuery = `
                items {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else if (availableFields.includes('nodes')) {
              fieldsToQuery = `
                nodes {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else if (availableFields.includes('suggestions')) {
              fieldsToQuery = `
                suggestions {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else if (availableFields.includes('data')) {
              fieldsToQuery = `
                data {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else {
              // If none of the common patterns exist, query ALL available fields
              // This will help us see what's actually there
              fieldsToQuery = availableFields.slice(0, 10).map(field => `
                ${field}
              `).join('');
              console.warn('Using all available fields:', availableFields.slice(0, 10));
            }
            
            // autocompleteSuggestionsPage expects AutocompleteSuggestionsQuery input object, not String
            const queryStr = `
              query AutocompleteSuggestions($integration_id: ID!, $slot: Int!, $query: AutocompleteSuggestionsQuery!) {
                ${queryName}(integration_id: $integration_id, slot: $slot, query: $query) {
                  ${fieldsToQuery}
                }
              }
            `;

            // AutocompleteSuggestionsQuery is an input object - need to pass object with text/q field
            const variables = {
              integration_id: MIROS_INTEGRATION_ID,
              slot: MIROS_SLOT,
              query: { text: urlQuery } // Try 'text' field first
            };

            try {
              let data;
              try {
                data = await callMirosAPI(queryStr, variables);
              } catch (error) {
                // Try with 'q' field if 'text' fails
                if (variables.query.text) {
                  variables.query = { q: urlQuery };
                  data = await callMirosAPI(queryStr, variables);
                } else {
                  throw error;
                }
              }
              
              // autocompleteSuggestionsPage might return edges/nodes or items
              const results = data[queryName];
              if (results?.edges && Array.isArray(results.edges)) {
                mirosData = results.edges.map(e => e.node).filter(Boolean);
              } else if (results?.items && Array.isArray(results.items)) {
                mirosData = results.items;
              } else if (results?.nodes && Array.isArray(results.nodes)) {
                mirosData = results.nodes;
              } else if (Array.isArray(results)) {
                mirosData = results;
              } else if (results && typeof results === 'object') {
                mirosData = results.data || results.results || [];
              }
            } catch (error) {
              console.error('URL search query failed:', error);
              throw error;
            }

          } else if (type === 'item') {
            // For item/SKU search, use autocompleteSuggestionsPage with the itemId as query
            const searchQuery = availableQueries.find(q => 
              q.name === 'autocompleteSuggestionsPage'
            );

            if (!searchQuery) {
              throw new Error('Autocomplete suggestions query not available');
            }

            const queryName = searchQuery.name;
            
            // Get actual fields available on AutocompleteSuggestionsPage
            const returnType = searchQuery.type?.ofType;
            const availableFields = returnType?.fields?.map(f => f.name) || [];
            console.log('AutocompleteSuggestionsPage available fields:', availableFields);
            
            // Build query dynamically based on what fields actually exist
            let fieldsToQuery = '';
            if (availableFields.includes('edges')) {
              fieldsToQuery = `edges { node { itemId title url imageUrl } }`;
            } else if (availableFields.includes('items')) {
              fieldsToQuery = `items { itemId title url imageUrl }`;
            } else if (availableFields.includes('nodes')) {
              fieldsToQuery = `nodes { itemId title url imageUrl }`;
            } else if (availableFields.includes('suggestions')) {
              fieldsToQuery = `suggestions { itemId title url imageUrl }`;
            } else {
              // Query all available fields to see structure
              fieldsToQuery = availableFields.slice(0, 10).join(' ');
              console.warn('Using all available fields:', availableFields.slice(0, 10));
            }
            
            const queryStr = `
              query AutocompleteSuggestions($integration_id: ID!, $slot: Int!, $query: AutocompleteSuggestionsQuery!) {
                ${queryName}(integration_id: $integration_id, slot: $slot, query: $query) {
                  ${fieldsToQuery}
                }
              }
            `;

            const variables = {
              integration_id: MIROS_INTEGRATION_ID,
              slot: MIROS_SLOT,
              query: { text: itemId }
            };

            try {
              let data;
              try {
                data = await callMirosAPI(queryStr, variables);
              } catch (error) {
                variables.query = { q: itemId };
                data = await callMirosAPI(queryStr, variables);
              }
              
              const results = data[queryName];
              if (results?.edges && Array.isArray(results.edges)) {
                mirosData = results.edges.map(e => e.node).filter(Boolean);
              } else if (results?.items && Array.isArray(results.items)) {
                mirosData = results.items;
              } else if (results?.nodes && Array.isArray(results.nodes)) {
                mirosData = results.nodes;
              } else if (Array.isArray(results)) {
                mirosData = results;
              } else if (results && typeof results === 'object') {
                mirosData = results.data || results.results || [];
              }
            } catch (error) {
              console.error('Item search query failed:', error);
              throw error;
            }

          } else if (type === 'nlp') {
            // Find autocompleteSuggestionsPage query (this is what's available)
            const searchQuery = availableQueries.find(q => 
              q.name === 'autocompleteSuggestionsPage'
            );

            if (!searchQuery) {
              // If no search query exists, we might need to use widget or different approach
              throw new Error('Search query not available in GraphQL schema. You may need to use the Miros widget or check API documentation.');
            }

            const queryName = searchQuery.name;
            const args = searchQuery.args || [];
            
            console.log(`Using search query: ${queryName} with args:`, args.map(a => a.name));

            // Get actual fields available on AutocompleteSuggestionsPage
            const returnType = searchQuery.type?.ofType;
            const availableFields = returnType?.fields?.map(f => f.name) || [];
            console.log('AutocompleteSuggestionsPage available fields:', availableFields);
            
            // Build query dynamically based on what fields actually exist
            let fieldsToQuery = '';
            if (availableFields.includes('edges')) {
              fieldsToQuery = `edges { node { itemId title url imageUrl } }`;
            } else if (availableFields.includes('items')) {
              fieldsToQuery = `items { itemId title url imageUrl }`;
            } else if (availableFields.includes('nodes')) {
              fieldsToQuery = `nodes { itemId title url imageUrl }`;
            } else if (availableFields.includes('suggestions')) {
              fieldsToQuery = `suggestions { itemId title url imageUrl }`;
            } else {
              // Query all available fields to see structure
              fieldsToQuery = availableFields.slice(0, 10).join(' ');
              console.warn('Using all available fields:', availableFields.slice(0, 10));
            }
            
            // autocompleteSuggestionsPage requires: integration_id, slot, query (AutocompleteSuggestionsQuery input object)
            const queryStr = `
              query AutocompleteSuggestions($integration_id: ID!, $slot: Int!, $query: AutocompleteSuggestionsQuery!) {
                ${queryName}(integration_id: $integration_id, slot: $slot, query: $query) {
                  ${fieldsToQuery}
                }
              }
            `;

            const variables = {
              integration_id: MIROS_INTEGRATION_ID,
              slot: MIROS_SLOT,
              query: { text: query } // AutocompleteSuggestionsQuery is an input object
            };

            try {
              let data;
              try {
                data = await callMirosAPI(queryStr, variables);
              } catch (error) {
                // Try with 'q' field if 'text' fails
                variables.query = { q: query };
                data = await callMirosAPI(queryStr, variables);
              }
              
              // autocompleteSuggestionsPage might return edges/nodes or items
              const results = data[queryName];
              if (results?.edges && Array.isArray(results.edges)) {
                mirosData = results.edges.map(e => e.node).filter(Boolean);
              } else if (results?.items && Array.isArray(results.items)) {
                mirosData = results.items;
              } else if (results?.nodes && Array.isArray(results.nodes)) {
                mirosData = results.nodes;
              } else if (Array.isArray(results)) {
                mirosData = results;
              } else if (results && typeof results === 'object') {
                mirosData = results.data || results.results || [];
              }
            } catch (error) {
              console.error('Autocomplete suggestions query failed:', error);
              throw error;
            }
          }

          return mirosData.slice(0, limit).map(transformMirosResult);
        }

        // Helper to extract items from various Miros response structures
        function extractItemsFromMirosResponse(data) {
          // Try different possible response structures
          if (data.autocompleteSuggestionsPage) {
            const page = data.autocompleteSuggestionsPage;
            return page.edges?.map(e => e.node) || 
                   page.items || 
                   page.nodes || 
                   page.suggestions || 
                   [];
          }
          if (data.search) {
            return Array.isArray(data.search) ? data.search : [];
          }
          if (data.itemRecommendations) {
            return Array.isArray(data.itemRecommendations) ? data.itemRecommendations : [];
          }
          return [];
        }

        // Listen for Miros widget events and extract results
        function setupMirosWidgetListener() {
          // Method 1: Listen for custom events from widget
          window.addEventListener('miros-results-loaded', (event) => {
            if (event.detail && event.detail.items) {
              const items = event.detail.items.map(transformMirosResult);
              appendUniqueProducts(items);
            }
          });

          // Method 2: Intercept network requests to capture widget's API responses
          const originalFetch = window.fetch;
          window.fetch = function(...args) {
            const url = args[0];
            if (typeof url === 'string' && url.includes('miros.services')) {
              return originalFetch.apply(this, args).then(response => {
                const clonedResponse = response.clone();
                clonedResponse.json().then(data => {
                  if (data && data.data) {
                    // Try to extract items from various response structures
                    const items = extractItemsFromMirosResponse(data.data);
                    if (items && items.length > 0) {
                      console.log('Captured items from widget API:', items);
                      const transformed = items.map(transformMirosResult);
                      appendUniqueProducts(transformed);
                    }
                  }
                }).catch(() => {});
                return response;
              });
            }
            return originalFetch.apply(this, args);
          };

          // Method 3: Use MutationObserver to watch widget DOM for results
          const observer = new MutationObserver((mutations) => {
            // Look for product elements in the widget overlay
            const widgetOverlay = document.querySelector('[data-miros-overlay], .miros-overlay, .miros-container, [id*="miros"]');
            if (widgetOverlay) {
              const productElements = widgetOverlay.querySelectorAll('[data-item-id], [data-product-id], .product-item, .suggestion-item, [data-suggestion]');
              if (productElements.length > 0) {
                const items = Array.from(productElements).map(el => {
                  const titleEl = el.querySelector('.title, .product-title, [data-title], h3, h4');
                  const linkEl = el.querySelector('a');
                  const imgEl = el.querySelector('img');
                  
                  return {
                    productTitle: titleEl?.textContent?.trim() || el.getAttribute('data-title') || el.getAttribute('alt') || '-',
                    optionId: el.getAttribute('data-item-id') || el.getAttribute('data-option-id') || el.getAttribute('data-product-id') || '-',
                    url: linkEl?.href || el.getAttribute('data-url') || el.getAttribute('href') || '',
                    imageUrl: imgEl ? (imgEl.src || imgEl.getAttribute('src') || '') : '',
                  };
                });
                if (items.length > 0) {
                  console.log('Extracted items from widget DOM:', items);
                  renderResults(items);
                  clearStatus();
                }
              }
            }
          });

          // Observe the document for widget changes
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }

        // Function to extract results from widget
        function tryExtractResultsFromWidget() {
          // Method 1: Check if widget exposes global API
          if (window.MirosWidget || window.miros) {
            const widget = window.MirosWidget || window.miros;
            if (widget && typeof widget.getResults === 'function') {
              widget.getResults().then(items => {
                if (items && items.length > 0) {
                  const transformed = items.map(transformMirosResult);
                  appendUniqueProducts(transformed);
                  return;
                }
              }).catch(() => {});
            }
            
            // Try other possible methods
            if (widget && typeof widget.getSuggestions === 'function') {
              widget.getSuggestions().then(items => {
                if (items && items.length > 0) {
                  const transformed = items.map(transformMirosResult);
                  appendUniqueProducts(transformed);
                }
              }).catch(() => {});
            }
          }

          // Method 2: Try to find results in DOM after a delay
          setTimeout(() => {
            const widgetOverlay = document.querySelector('[data-miros-overlay], .miros-overlay, [id*="miros"], [class*="miros"]');
            if (widgetOverlay) {
              // Look for product cards/images in the widget
              const productCards = widgetOverlay.querySelectorAll('img[src*="product"], .product-card, [data-product], [data-item-id]');
              
              if (productCards.length > 0) {
                const items = Array.from(productCards).map(card => {
                  const parent = card.closest('[data-item-id], [data-product-id], .product-item') || card.parentElement;
                  const imgEl = card.tagName === 'IMG' ? card : card.querySelector('img');
                  return {
                    productTitle: parent.querySelector('.title, .product-title, [data-title]')?.textContent?.trim() || card.getAttribute('alt') || '-',
                    optionId: parent.getAttribute('data-item-id') || card.getAttribute('data-item-id') || '-',
                    url: parent.querySelector('a')?.href || card.closest('a')?.href || '',
                    imageUrl: imgEl ? (imgEl.src || imgEl.getAttribute('src') || '') : '',
                  };
                });
                
                if (items.length > 0) {
                  appendUniqueProducts(items);
                }
              }
            }
          }, 1000);
        }

        // This helper sets data attributes so the Miros widget knows what to search for next.
        const prepareEntry = (attributes) => {
          if (!mirosEntry) return;

          ENTRY_ATTRS.forEach((attr) => {
            const attrName = `data-miros-${attr}`;
            if (attributes[attr]) {
              mirosEntry.setAttribute(attrName, attributes[attr]);
            } else {
              mirosEntry.removeAttribute(attrName);
            }
          });
        };

        // Helper to open Miros widget overlay
        const openMirosOverlay = () => {
          // The Miros widget injects an AI search button - we need to click that
          // Try multiple selectors to find the AI button
          const aiButton = 
            document.querySelector('button.miros-search-on-entry-point') ||
            document.querySelector('[class*="miros-search-on-entry-point"]') ||
            document.querySelector('button[class*="miros"][class*="search"]') ||
            document.querySelector('button[aria-label*="search" i]') ||
            document.querySelector('[data-miros-entry="miros-on-search"] button') ||
            document.querySelector('#mirosEntry button') ||
            document.querySelector('button[class*="miros-box-border"]');
          
          if (aiButton) {
            console.log('Found AI button, clicking it to open overlay');
            aiButton.click();
            return;
          }
          
          // Fallback: try clicking mirosEntry or triggering event
          if (mirosEntry) {
            console.log('AI button not found, trying to click mirosEntry');
            // Try multiple ways to trigger the overlay
            mirosEntry.click();
            mirosEntry.dispatchEvent(
              new MouseEvent("click", {
                bubbles: true,
                cancelable: true,
                view: window,
              }),
            );
          } else {
            console.warn('No mirosEntry found and no AI button found');
          }
        };

        // Helper to close Miros widget overlay
        const closeMirosOverlay = () => {
          console.log('Attempting to close Miros overlay...');
          
          // Method 1: Find and click close button
          const closeButtonSelectors = [
            'button[aria-label*="close" i]',
            'button[aria-label*="×"]',
            'button[aria-label*="Close"]',
            '[class*="close"] button',
            '[class*="close-button"]',
            '[class*="modal-close"]',
            '[class*="overlay-close"]',
            'button.close',
            '.close-button',
            '[data-dismiss="modal"]',
            '[data-close]'
          ];
          
          for (const selector of closeButtonSelectors) {
            const closeBtn = document.querySelector(selector);
            if (closeBtn && closeBtn.offsetParent !== null) { // Check if visible
              console.log('Found close button, clicking:', selector);
              closeBtn.click();
              // Wait a bit and check if overlay closed
              setTimeout(() => {
                const overlay = document.querySelector('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]');
                if (overlay && overlay.id !== 'focusOverlay') {
                  console.log('Overlay still open, trying ESC key...');
                  // Try ESC key
                  document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape', keyCode: 27, bubbles: true }));
                }
              }, 300);
              return true;
            }
          }
          
          // Method 2: Try ESC key
          console.log('Close button not found, trying ESC key...');
          document.dispatchEvent(new KeyboardEvent('keydown', { key: 'Escape', keyCode: 27, bubbles: true }));
          document.dispatchEvent(new KeyboardEvent('keyup', { key: 'Escape', keyCode: 27, bubbles: true }));
          
          // Method 3: Hide overlay with CSS as fallback
          setTimeout(() => {
            const overlay = document.querySelector('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]');
            if (overlay && overlay.id !== 'focusOverlay' && !overlay.classList.contains('focus-overlay')) {
              console.log('Hiding overlay with CSS as fallback');
              overlay.style.display = 'none';
              overlay.style.visibility = 'hidden';
              overlay.style.opacity = '0';
              // Also hide any backdrop
              const backdrop = document.querySelector('[class*="backdrop"], [class*="overlay-backdrop"]');
              if (backdrop) {
                backdrop.style.display = 'none';
              }
            }
          }, 500);
          
          return false;
        };

        // Upload image and get data URL (no backend needed - widget handles it)
        const uploadImageToMiros = async (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            reader.onload = (e) => {
              const imageUrl = e.target.result; // Data URL
              resolve({ imageUrl });
            };
            
            reader.onerror = () => {
              reject(new Error("Failed to read image file"));
            };
            
            reader.readAsDataURL(file);
          });
        };

        if (trigger && fileInput) {
          trigger.addEventListener("click", () => {
            clearStatus();
            fileInput.click();
          });

          fileInput.addEventListener("change", async (event) => {
            clearStatus();
            const file = event.target.files?.[0];
            if (!file) return;

            try {
              showStatus("Searching by image…", "pending");
              const { imageUrl } = await uploadImageToMiros(file);
              
              // For image search, we'd need to use Miros image search API
              // This is a placeholder - you may need to implement image upload endpoint
              // or use Miros image search GraphQL mutation
              showStatus("Image search not yet implemented via direct API. Please use text/SKU search.", "error");
              
              // TODO: Implement image search via Miros GraphQL if available
              // Example: mutation { searchByImage(imageUrl: $imageUrl, limit: 15) { ... } }
              
            } catch (error) {
              console.error(error);
              showStatus(
                "Unable to process image. Please try again.",
                "error",
              );
            } finally {
              fileInput.value = "";
            }
          });
        }

        // Main search function
        const performSearch = async () => {
            clearStatus();
            const rawValue = searchInput.value.trim();

            if (!rawValue) {
              showStatus("Enter a search term or SKU to continue.", "error");
              return;
            }

          // CRITICAL: Transition to STATE 2 immediately when search is clicked
          if (!hasSearched) {
            showResultsSection();
          }

          prepareResultsForNewSearch();

            const isSku = /^[A-Za-z0-9_-]+$/.test(rawValue);
            const attributes = {};

            if (isSku) {
              attributes.item = rawValue;
              attributes.nlp = "";
            } else {
              attributes.item = "";
              attributes.nlp = rawValue;
              attributes.category = categorySelect?.value || "";
            }

          // Try direct API fetch first (guarantees up to 100 items when available)
          let directResults = [];
          if (MIROS_API_KEY) {
            showStatus("Fetching products via Miros API...", "pending");
            try {
              console.log('=== Starting direct API fetch with limit: 100 ===');
              directResults = await fetchProductsViaAPI(rawValue);
              console.log(`API fetch returned ${directResults.length} products`);
            } catch (error) {
              console.error('Direct Miros API fetch failed, falling back to widget overlay.', error);
            }
          }

          if (directResults.length) {
            console.log(`Adding ${directResults.length} products from API to table`);
            appendUniqueProducts(directResults, { reset: true, silent: true });
            console.log(`Total products after API fetch: ${allProducts.length}`);
          }

          if (allProducts.length >= TARGET_PRODUCT_COUNT) {
            showStatus(`Loaded ${allProducts.length} products via Miros API.`, "success");
            setTimeout(() => clearStatus(), 2000);
            return;
          }

          // Configure Miros widget with the current query for overlay fallback
            prepareEntry(attributes);

          const needsOverlay = allProducts.length < TARGET_PRODUCT_COUNT;
          if (!needsOverlay) {
            showStatus(`Loaded ${allProducts.length} products via Miros API.`, "success");
            setTimeout(() => clearStatus(), 2000);
            return;
          }

          showStatus(`Loading ${TARGET_PRODUCT_COUNT} products from Miros...`, "pending");
            
            // Try to find and click the AI button immediately, then retry if not found
            const tryOpenOverlay = (attempt = 0) => {
              const aiButton = 
                document.querySelector('button.miros-search-on-entry-point') ||
                document.querySelector('[class*="miros-search-on-entry-point"]') ||
                document.querySelector('button[class*="miros"][class*="search"]') ||
                document.querySelector('[data-miros-entry="miros-on-search"] button') ||
                document.querySelector('#mirosEntry button');
              
              if (aiButton) {
                console.log('Found AI button, clicking to open overlay');
                aiButton.click();
                
                // Set up scraping after overlay opens
                let observer = null;
                let scrapeAttempts = 0;
                const maxScrapeAttempts = 15; // Try for up to 15 seconds
                const scrapeRetryInterval = 500; // Check every 500ms

                const tryScraping = async () => {
                // CRITICAL: Check max attempts BEFORE incrementing to prevent going over
                if (scrapeAttempts >= maxScrapeAttempts) {
                    if (observer) observer.disconnect();
                    console.error('Failed to find overlay after all attempts. Debug info:');
                    console.log('All Miros elements:', document.querySelectorAll('[id*="miros"], [class*="miros"], [data-miros]'));
                    console.log('All dialogs/modals:', document.querySelectorAll('[role="dialog"], .modal, [class*="overlay"]'));
                    console.log('All links with /p/:', document.querySelectorAll('a[href*="/p/"]'));
                  
                  // Try one more time with direct link extraction as fallback
                  const allProductLinks = Array.from(document.querySelectorAll('a[href*="/p/"]'))
                    .filter(link => {
                      const href = link.href || link.getAttribute('href') || '';
                      return href.includes('/p/') && (href.includes('centrepointstores.com') || href.includes('centrepoint'));
                    });
                  
                  if (allProductLinks.length > 0) {
                    console.log(`Found ${allProductLinks.length} product links directly, extracting...`);
                    // Sort links by visual position
                    const sortedLinks = Array.from(allProductLinks).sort((a, b) => {
                      const rectA = a.getBoundingClientRect();
                      const rectB = b.getBoundingClientRect();
                      const topDiff = rectA.top - rectB.top;
                      if (Math.abs(topDiff) > 50) {
                        return topDiff;
                      }
                      return rectA.left - rectB.left;
                    });
                    
                    const items = sortedLinks.map(link => {
                      const url = link.href || link.getAttribute('href') || '';
                      const match = url.match(/\/p\/([^?]+)/);
                      const optionId = match ? match[1] : '-';
                      const titleEl = link.querySelector('img[alt], .title, [class*="title"], [class*="name"]');
                      const productTitle = titleEl?.textContent?.trim() || titleEl?.getAttribute('alt') || link.textContent?.trim() || 'Product';
                      const img = link.querySelector('img[src]');
                      const imageUrl = img ? (img.src || img.getAttribute('src') || '') : '';
                      
                      return {
                        productTitle: productTitle.substring(0, 150),
                        optionId: optionId,
                        url: url,
                        imageUrl: imageUrl,
                      };
                    });
                    
                    // Store all products and initialize pagination
                    allProducts = items;
                    currentPage = 1;
                    updatePagination();
                    renderResults(getCurrentPageItems());
                    
                    // Close overlay after extraction
                    setTimeout(() => {
                      closeMirosOverlay();
                      showStatus(`Loaded ${allProducts.length} products successfully!`, "success");
                      setTimeout(() => clearStatus(), 2000);
                    }, 500);
                    return;
                  }
                    
                    showStatus("No results found. Try a different URL, SKU, or product attribute.", "error");
                  renderResults([]);
                  
                  // Close overlay even if no results found
                  setTimeout(() => {
                    closeMirosOverlay();
                  }, 1000);
                  
                    setTimeout(() => clearStatus(), 3000);
                  return;
                }
                
                  scrapeAttempts++;
                  console.log(`Attempt ${scrapeAttempts}/${maxScrapeAttempts} to scrape overlay`);
                  const success = await scrapeMirosOverlayIntoTable();
                  
                  if (success) {
                    if (observer) observer.disconnect();
                    // Don't show success message here - it will be shown after scrolling completes
                    // The scrapeMirosOverlayIntoTable function will handle closing the overlay
                } else {
                    // Keep trying
                    showStatus(`Waiting for overlay to load... (${scrapeAttempts}/${maxScrapeAttempts})`, "pending");
                    setTimeout(tryScraping, scrapeRetryInterval);
                  }
                };

                // Use MutationObserver to detect when overlay appears
                observer = new MutationObserver((mutations) => {
                  // Check if any new Miros elements appeared
                  const hasNewMirosElements = mutations.some(mutation => {
                    return Array.from(mutation.addedNodes).some(node => {
                      if (node.nodeType !== 1) return false; // Not an element
                      return node.querySelector && (
                        node.querySelector('[id*="miros"], [class*="miros"], [data-miros]') ||
                        node.id?.includes('miros') ||
                        node.className?.includes('miros')
                      );
                    });
                  });
                  
                  if (hasNewMirosElements) {
                    console.log('Detected new Miros elements, attempting to scrape...');
                    setTimeout(() => tryScraping(), 300); // Small delay to let DOM settle
                  }
                });

                // Start observing
                observer.observe(document.body, {
                  childList: true,
                  subtree: true,
                  attributes: false
                });

                // Also start polling after initial delay (backup method)
                setTimeout(tryScraping, 500);
                
              } else if (attempt < 10) {
                // Widget might still be loading, try again
                setTimeout(() => tryOpenOverlay(attempt + 1), 200);
              } else {
                // Fallback to old method
                console.warn('AI button not found after retries, using fallback');
                openMirosOverlay();
              }
            };
            
            tryOpenOverlay();
        };

        // Attach search to both buttons - ensure focus mode exits
        if (searchBtn && searchInput) {
          searchBtn.addEventListener("click", () => {
            exitFocusOnSearch();
            performSearch();
          });
        }

        if (clearResultsBtn) {
          clearResultsBtn.addEventListener("click", () => {
            clearStatus();
            clearResults();
          });
        }

        // Download results as Excel file
        if (downloadButton) {
          downloadButton.addEventListener("click", () => {
            try {
              const rows = resultsBody.querySelectorAll("tr");
              if (!rows || rows.length === 0 || (rows.length === 1 && rows[0].querySelector(".results-empty"))) {
                showStatus("No results to download.", "error");
                setTimeout(() => clearStatus(), 2000);
                return;
              }

              const dataRows = Array.from(rows).filter(row => !row.querySelector(".results-empty"));

              if (!dataRows.length) {
                showStatus("No data to download.", "error");
                setTimeout(() => clearStatus(), 2000);
                return;
              }

              if (typeof XLSX === "undefined") {
                showStatus("Excel library not loaded. Please refresh the page.", "error");
                setTimeout(() => clearStatus(), 3000);
                return;
              }

              // Get all headers but exclude the first one (Product Image)
              const allHeaders = Array.from(document.querySelectorAll(".results-grid thead th")).map(
                (th) => th.textContent.trim()
              );
              const headers = allHeaders.slice(1); // Skip first column (Product Image)

              // Export all products, not just current page
              const data = allProducts.map((item) => {
                const productId = deriveProductIdFromSource(item.url, item.optionId);
                
                // Truncate URL for display
                let displayUrl = item.url;
                if (item.url && item.url.length > 25) {
                  displayUrl = item.url.substring(0, 22) + '...';
                }
                
                return [
                  item.productTitle || "-",
                  productId || "-",
                  item.url || "-"
                ];
              });

              const worksheetData = [headers, ...data];
              const wb = XLSX.utils.book_new();
              const ws = XLSX.utils.aoa_to_sheet(worksheetData);

              const colWidths = headers.map((_, index) => {
                const maxLength = worksheetData.reduce((max, row) => {
                  const cell = row[index] || "";
                  return Math.max(max, cell.toString().length);
                }, 10);
                return { wch: Math.min(Math.max(maxLength + 2, 12), 60) };
              });
              ws["!cols"] = colWidths;

              XLSX.utils.book_append_sheet(wb, ws, "Search Results");
              const fileName = `miros-search-results-${new Date().toISOString().split("T")[0]}.xlsx`;
              XLSX.writeFile(wb, fileName);

              showStatus("Results downloaded successfully!", "success");
              setTimeout(() => clearStatus(), 2000);
            } catch (error) {
              console.error("Download failed:", error);
              showStatus("Could not download results. Check console for details.", "error");
              setTimeout(() => clearStatus(), 3000);
            }
          });
        }

        // Initialize widget listener when page loads
        setupMirosWidgetListener();
      })();
    </script>
    
  </body>
</html>


