<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Smart Product Recommendations</title>
    <link rel="stylesheet" href="styles.css" />
    <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
    <script type="module" src="https://content.miros.services/frontend/public/main/container/assets/container.bundle.js" data-miros-integration-id="fb97f7d4-fe95-402f-a81a-402cb062eaa3"></script>
  </head>
  <body>
    <div class="focus-overlay" id="focusOverlay"></div>
    <main class="dashboard">
      <!-- Landing Screen -->
      <div class="dashboard__landing" id="landingScreen">
        <div class="dashboard__landing-content">
          <div class="dashboard__header-title">
            <h1 class="dashboard__title">Smart Product Recommendations</h1>
            <p class="dashboard__subtitle">Paste a link, SKU, or product name to find similar items</p>
          </div>
          <div class="dashboard__landing-search">
            <div class="dashboard__search-inline">
              <div class="dashboard__input-wrapper">
                <svg class="dashboard__search-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M9 17C13.4183 17 17 13.4183 17 9C17 4.58172 13.4183 1 9 1C4.58172 1 1 4.58172 1 9C1 13.4183 4.58172 17 9 17Z" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M19 19L14.65 14.65" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <input
                  type="text"
                  class="dashboard__input"
                  id="landingSearchInput"
                  placeholder="Search for a product attribute"
                  aria-label="Search for a product attribute"
                />
              </div>
              <div
                id="mirosEntryLanding"
                data-miros-entry="miros-on-search"
                class="miros-entry-wrapper"
              ></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Results Screen Header -->
      <header class="dashboard__header" id="dashboardHeader" style="display: none;">
        <div class="dashboard__header-content">
          <div class="dashboard__search-container">
            <div class="dashboard__search-inline">
              <div class="dashboard__input-wrapper">
                <svg class="dashboard__search-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M9 17C13.4183 17 17 13.4183 17 9C17 4.58172 13.4183 1 9 1C4.58172 1 1 4.58172 1 9C1 13.4183 4.58172 17 9 17Z" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M19 19L14.65 14.65" stroke="#000000" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
                <input
                  type="text"
                  class="dashboard__input"
                  id="searchInput"
                  placeholder="Search for a product attribute"
                  aria-label="Search for a product attribute"
                />
              </div>
              <div class="dashboard__category-wrapper" style="display: none;">
                <select
                  class="dashboard__select"
                  id="categorySelect"
                  aria-label="Select product category"
                  disabled
                >
                  <option value="Fashion">Fashion</option>
                  <option value="Womenswear">Womenswear</option>
                  <option value="Menswear">Menswear</option>
                  <option value="Accessories">Accessories</option>
                  <option value="Footwear">Footwear</option>
                </select>
              </div>
              <div
                id="mirosEntry"
                data-miros-entry="miros-on-search"
                class="miros-entry-wrapper"
              ></div>
            </div>
          </div>
          <button type="button" class="dashboard__button dashboard__button--download" id="downloadButton">Download as .csv</button>
        </div>
      </header>

      <!-- Scroll-Reactive Filters Header -->
      <div class="dashboard__filters-header" id="filtersHeader" style="display: none;">
        <div class="dashboard__filters-header-content">
          <div class="filters-container" id="filtersContainer" style="display: flex;">
            <div class="filter-group">
              <label class="filter-label">Brand</label>
              <div class="filter-multiselect" id="brandFilter">
                <div class="filter-multiselect__selected" id="brandFilterSelected">
                  <span class="filter-placeholder">Select brands...</span>
                </div>
                <div class="filter-multiselect__dropdown" id="brandFilterDropdown" style="display: none;">
                  <div class="filter-multiselect__search">
                    <input type="text" id="brandFilterSearch" placeholder="Search brands..." class="filter-search-input">
                  </div>
                  <div class="filter-multiselect__options" id="brandFilterOptions"></div>
                </div>
              </div>
            </div>
            
            <div class="filter-group">
              <label class="filter-label">Color</label>
              <div class="filter-multiselect" id="colorFilter">
                <div class="filter-multiselect__selected" id="colorFilterSelected">
                  <span class="filter-placeholder">Select colors...</span>
                </div>
                <div class="filter-multiselect__dropdown" id="colorFilterDropdown" style="display: none;">
                  <div class="filter-multiselect__search">
                    <input type="text" id="colorFilterSearch" placeholder="Search colors..." class="filter-search-input">
                  </div>
                  <div class="filter-multiselect__options" id="colorFilterOptions"></div>
                </div>
              </div>
            </div>
            
            <button type="button" class="filter-clear-btn" id="clearFiltersBtn" style="display: none;">
              Clear Filters
            </button>
          </div>
          <div class="selected-filters-container" id="selectedFiltersContainer" style="display: none;"></div>
        </div>
      </div>
      <p class="dashboard__status" id="statusMessage" aria-live="polite"></p>
      <section class="dashboard__results" id="dashboardResults">
            <div>
          <div class="results-summary" id="resultsSummary" style="display: none;">
            <span class="results-summary__text" id="resultsSummaryText">
              Enter a search term or SKU ID to see product-level recommendations here.
            </span>
          </div>
          <div class="results-grid-wrapper" role="region" aria-live="polite">
            <div class="results-cards-grid" id="resultsBody">
              <div class="results-empty">
                Waiting for your first search‚Ä¶
              </div>
            </div>
          </div>
        </div>
      </section>
    </main>
    <script>
      (function () {
        const searchBtn = null; // Search button removed - using Enter key only
        const landingSearchInput = document.getElementById("landingSearchInput");
        const searchInput = document.getElementById("searchInput");
        const landingScreen = document.getElementById("landingScreen");
        const categorySelect = document.getElementById("categorySelect");
        const mirosEntry = document.getElementById("mirosEntry");
        const mirosEntryLanding = document.getElementById("mirosEntryLanding");
        const statusMessage = document.getElementById("statusMessage");
        
        // Track which buttons have handlers attached to prevent duplicates
        const buttonsWithHandlers = new WeakSet();
        
        // Show Miros entry button (for both landing and results screens)
        const showMirosEntryButton = (entryElement = null) => {
          if (!ENABLE_MIROS_OVERLAY_BUTTON) return;
          
          const targetElement = entryElement || mirosEntry;
          if (!targetElement) return;
          
          // Check if we already have an observer for this element
          if (targetElement._mirosObserver) {
            return; // Already set up
          }
          
          targetElement.classList.add('visible');
          
          // Use MutationObserver to watch for button injection by Miros widget
          const observer = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
              if (mutation.addedNodes.length > 0) {
                // Button was injected, ensure it's visible and add click handler
                const button = targetElement.querySelector('button, [class*="miros"]');
                if (button && !buttonsWithHandlers.has(button)) {
                  button.style.display = 'flex';
                  
                  // Mark button as having handler
                  buttonsWithHandlers.add(button);
                  
                  // Function to update entry attributes
                  const updateEntryAttributes = () => {
                    // Get search query from appropriate input
                    const searchValue = currentSearchQuery || 
                                      (searchInput ? searchInput.value.trim() : '') ||
                                      (document.getElementById('landingSearchInput') ? document.getElementById('landingSearchInput').value.trim() : '');
                    
                    // Prepare entry with current search query
                    const isSku = /^[A-Za-z0-9_-]+$/.test(searchValue);
                    const attributes = {};
                    if (isSku) {
                      attributes.item = searchValue;
                      attributes.nlp = "";
                    } else {
                      attributes.item = "";
                      attributes.nlp = searchValue;
                    }
                    
                    // Prepare entry for the correct element
                    if (targetElement === mirosEntryLanding) {
                      prepareEntryForElement(mirosEntryLanding, attributes);
                    } else {
                      prepareEntry(attributes);
                    }
                  };
                  
                  // Update attributes immediately
                  updateEntryAttributes();
                  
                  // Update attributes before each click (so Miros widget gets current search)
                  // Use capture phase to update BEFORE Miros's handler runs
                  button.addEventListener('click', function handleMirosButtonClick(e) {
                    // Update attributes right before the click propagates
                    updateEntryAttributes();
                    // Don't prevent default - let Miros button's native handler work
                  }, true); // Use capture phase
                  
                  // Also update when search inputs change
                  if (searchInput) {
                    searchInput.addEventListener('input', updateEntryAttributes);
                    searchInput.addEventListener('change', updateEntryAttributes);
                  }
                  const landingInput = document.getElementById('landingSearchInput');
                  if (landingInput) {
                    landingInput.addEventListener('input', updateEntryAttributes);
                    landingInput.addEventListener('change', updateEntryAttributes);
                  }
                  
                  // Disconnect observer once button is set up
                  observer.disconnect();
                  targetElement._mirosObserver = null;
                }
              }
            });
          });
          
          // Store observer reference
          targetElement._mirosObserver = observer;
          observer.observe(targetElement, { childList: true, subtree: true });
        };
        
        // Initialize Miros buttons on page load
        const initializeMirosButtons = () => {
          if (!ENABLE_MIROS_OVERLAY_BUTTON) return;
          
          // Show button in landing screen immediately
          if (mirosEntryLanding) {
            mirosEntryLanding.classList.add('visible');
            // Wait for Miros widget to inject the button, then set it up
            setTimeout(() => {
              showMirosEntryButton(mirosEntryLanding);
            }, 1500);
          }
          
          // Show button in results screen (will be shown after search)
          if (mirosEntry) {
            // Already handled by showMirosEntryButton() after search
          }
        };
        const resultsSummary = document.getElementById("resultsSummary");
        const resultsSummaryText = document.getElementById("resultsSummaryText");
        const resultsBody = document.getElementById("resultsBody");
        const downloadButton = document.getElementById("downloadButton");
        const dashboardResults = document.getElementById("dashboardResults");
        const dashboardHeader = document.getElementById("dashboardHeader");
        const filtersHeader = document.getElementById("filtersHeader");
        const focusOverlay = document.getElementById("focusOverlay");

        // State management
        let hasSearched = false;
        let isFocusMode = false;
        let allProducts = []; // Store all scraped products
        let originalProducts = []; // Store original unfiltered products
        let displayedProductsCount = 0; // Track how many products are currently displayed
        const itemsPerLoad = 50; // Load 50 products at a time when scrolling
        let isLoadingMore = false; // Prevent multiple simultaneous loads
        let statusHideTimer = null;
        let lastStatusUpdate = 0;
        let lastStatusText = "";
        let currentSearchQuery = ""; // Store current search query for filename generation
        
        // Filter state
        let selectedBrands = new Set();
        let selectedColors = new Set();
        let allBrands = new Set();
        let allColors = new Set();

        // STATE 1: Initial State - hide results on first load
        if (dashboardResults) {
          dashboardResults.style.display = 'none';
        }
        if (landingScreen) {
          landingScreen.style.display = 'flex';
        }
        if (dashboardHeader) {
          dashboardHeader.style.display = 'none';
        }
        if (filtersHeader) {
          filtersHeader.style.display = 'none';
        }

        // Note: Search button handlers are set up later in performSearch section

        // STATE 3: Focus Mode - when clicking search input after search
        const enterFocusMode = () => {
          if (!hasSearched) return; // Only work in STATE 2
          
          isFocusMode = true;
          document.body.classList.add('focus-mode');
          if (focusOverlay) {
            focusOverlay.classList.add('active');
          }
          if (dashboardHeader) {
            dashboardHeader.classList.add('focused');
          }
          // Don't blur product grid on focus
          // if (dashboardResults) {
          //   dashboardResults.classList.add('faded');
          // }
        };

        // Exit focus mode - return to STATE 2
        const exitFocusMode = () => {
          isFocusMode = false;
          document.body.classList.remove('focus-mode');
          if (focusOverlay) {
            focusOverlay.classList.remove('active');
          }
          if (dashboardHeader) {
            dashboardHeader.classList.remove('focused');
          }
          if (dashboardResults) {
            dashboardResults.classList.remove('faded');
          }
        };

        // Show results section after first search - STATE 2: Searched State
        const showResultsSection = () => {
          if (hasSearched) return; // Already shown, don't duplicate
          
          hasSearched = true;
          document.body.classList.add('has-results');
          
          // Hide landing screen, show header and results - NO TRANSITION
          if (landingScreen) {
            landingScreen.style.display = 'none';
          }
          if (dashboardHeader) {
            dashboardHeader.style.display = 'block';
          }
          if (filtersHeader) {
            filtersHeader.style.display = 'block';
          }
          if (dashboardResults) {
            dashboardResults.style.display = 'flex';
            dashboardResults.style.opacity = '1';
            dashboardResults.style.transform = 'none';
            dashboardResults.classList.add('visible');
          }
          
          // Show filters container when filters header becomes visible
          const filtersContainer = document.getElementById('filtersContainer');
          if (filtersContainer) {
            filtersContainer.style.display = 'flex';
          }
          
          // Exit focus mode if active
          exitFocusMode();
          
          // Initialize scroll-reactive filters header
          setupScrollReactiveFiltersHeader();
        };
        
        // Scroll-reactive filters header - hide on scroll down, show on scroll up
        let lastScrollY = 0;
        let scrollTimeout = null;
        
        function setupScrollReactiveFiltersHeader() {
          if (!filtersHeader || !dashboardHeader) return;
          
          // Calculate header height dynamically
          const updateFiltersHeaderTop = () => {
            if (dashboardHeader && filtersHeader) {
              const headerHeight = dashboardHeader.offsetHeight;
              filtersHeader.style.top = `${headerHeight}px`;
            }
          };
          
          // Update on load and resize
          updateFiltersHeaderTop();
          window.addEventListener('resize', updateFiltersHeaderTop);
          
          // Reset scroll position
          lastScrollY = window.scrollY || window.pageYOffset;
          
          const handleScroll = () => {
            const currentScrollY = window.scrollY || window.pageYOffset;
            const scrollDifference = currentScrollY - lastScrollY;
            
            // Only react if scrolled more than 5px to avoid jitter
            if (Math.abs(scrollDifference) > 5) {
              if (scrollDifference > 0 && currentScrollY > 100) {
                // Scrolling down - hide filters header
                filtersHeader.classList.add('hidden');
              } else if (scrollDifference < 0) {
                // Scrolling up - show filters header
                filtersHeader.classList.remove('hidden');
              }
              
              lastScrollY = currentScrollY;
            }
            
            // Show header when at top of page
            if (currentScrollY < 50) {
              filtersHeader.classList.remove('hidden');
            }
          };
          
          // Throttle scroll events
          let ticking = false;
          window.addEventListener('scroll', () => {
            if (!ticking) {
              window.requestAnimationFrame(() => {
                handleScroll();
                ticking = false;
              });
              ticking = true;
            }
          }, { passive: true });
        };

        // Focus mode: click overlay to exit
        if (focusOverlay) {
          focusOverlay.addEventListener('click', (e) => {
            if (isFocusMode && e.target === focusOverlay) {
              exitFocusMode();
              searchInput?.blur();
            }
          });
        }

        // Landing search input handlers
        if (landingSearchInput) {
          const handleLandingSearch = () => {
            const searchValue = landingSearchInput.value.trim();
            if (!searchValue) return;
            
            // Copy value to header search input
            if (searchInput) {
              searchInput.value = searchValue;
            }
            
            // Switch to results screen immediately (no transition)
            showResultsSection();
            
            // Trigger search
            setTimeout(() => {
              performSearch();
            }, 0);
          };

          // Handle Enter key on landing search
          landingSearchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              handleLandingSearch();
            }
          });

          // Handle paste on landing search
          landingSearchInput.addEventListener('paste', (e) => {
            setTimeout(() => {
              const pastedValue = landingSearchInput.value.trim();
              if (pastedValue && (pastedValue.startsWith('http') || pastedValue.includes('/p/'))) {
                handleLandingSearch();
              }
            }, 10);
          });
        }

        // Enter focus mode on search input focus (only after first search)
        if (searchInput) {
          searchInput.addEventListener('focus', () => {
            if (hasSearched) {
              enterFocusMode();
            }
          });

          // Exit focus mode on blur
          searchInput.addEventListener('blur', (e) => {
            setTimeout(() => {
              if (!document.activeElement || 
                  document.activeElement !== searchInput) {
                exitFocusMode();
              }
            }, 200);
          });

          // Handle paste events - both on input and document level for better image paste support
          const handlePaste = async (e) => {
            // Only handle if search input is focused or if it's a document-level paste
            const isInputFocused = document.activeElement === searchInput;
            const isDocumentPaste = e.target === document.body || e.target === document.documentElement;
            
            if (!isInputFocused && !isDocumentPaste) {
              return;
            }
            
            // Handle text paste (only if input is focused)
            if (isInputFocused) {
              setTimeout(() => {
                const pastedValue = searchInput.value.trim();
                if (pastedValue && (pastedValue.startsWith('http') || pastedValue.includes('/p/'))) {
                  // Auto-trigger search for URLs
                  if (searchInput) {
                    setTimeout(() => {
                      performSearch();
                    }, 100);
                  }
                }
              }, 10);
            }
          };
          
          // Add paste listener to input
          searchInput.addEventListener('paste', handlePaste);

          const triggerSearchOnEnter = (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              exitFocusOnSearch();
              performSearch();
            }
          };

          // Also listen globally so Enter works even when focus mode overlay is active
          document.addEventListener('keydown', (e) => {
            if (document.activeElement === searchInput) {
              triggerSearchOnEnter(e);
            }
          });
        }

        // Exit focus mode when search button is clicked - returns to STATE 2
        const exitFocusOnSearch = () => {
          exitFocusMode();
        };

        const ENTRY_ATTRS = [
          "item",
          "nlp",
          "category",
          "image-url",
          "sizes",
          "lang",
        ];

        const deriveProductIdFromSource = (productUrl = "", fallbackValue = "") => {
          if (productUrl) {
            const match = String(productUrl).match(/\/p\/([^/?]+)/i);
            if (match && match[1]) {
              return decodeURIComponent(match[1]);
            }
          }
          const normalizedFallback =
            typeof fallbackValue === "number"
              ? String(fallbackValue)
              : (fallbackValue || "").toString().trim();
          return normalizedFallback || "-";
        };

        // This helper shows a friendly status message so people know what is happening.
        const showStatus = (message, type = "info", options = {}) => {
          if (!statusMessage) return;
          const { autoHideDelay = 6000 } = options;
          
          statusMessage.textContent = message;
          statusMessage.dataset.status = type;
          statusMessage.classList.add("visible");
          lastStatusText = message;
          lastStatusUpdate = Date.now();
          
          if (statusHideTimer) {
            clearTimeout(statusHideTimer);
            statusHideTimer = null;
          }
          
          if (type === "pending") {
            statusHideTimer = setTimeout(() => {
              const isStale = Date.now() - lastStatusUpdate >= autoHideDelay - 50;
              if (isStale) {
                clearStatus();
              }
            }, autoHideDelay);
          }
        };

        // This helper wipes the status text when we are done talking to the user.
        const clearStatus = () => {
          if (!statusMessage) return;
          if (statusHideTimer) {
            clearTimeout(statusHideTimer);
            statusHideTimer = null;
          }
          statusMessage.textContent = "";
          statusMessage.dataset.status = "";
          statusMessage.classList.remove("visible");
          lastStatusText = "";
        };

        // This helper turns the raw number of hits into a short sentence kids can read.
        const summariseResults = (count) => {
          if (!resultsSummaryText) return;

          if (!count) {
            resultsSummaryText.textContent =
              "No matches returned from Miros. Adjust filters or try another input.";
            return;
          }

          resultsSummaryText.textContent = `${count} product${
            count === 1 ? "" : "s"
          } returned from Miros.`;
        };

        // This helper resets the table so we are not showing old items by mistake.
        const clearResults = () => {
          allProducts = [];
          originalProducts = [];
          displayedProductsCount = 0;
          selectedBrands.clear();
          selectedColors.clear();
          allBrands.clear();
          allColors.clear();
          if (resultsBody) {
            resultsBody.innerHTML =
              '<div class="results-empty">Results cleared. Run a new search to see recommendations.</div>';
          }
          if (resultsSummaryText) {
            resultsSummaryText.textContent =
              "Results cleared. Enter a new search term or SKU ID to refresh.";
          }
          // Keep filters container visible even when clearing results
          const filtersContainer = document.getElementById('filtersContainer');
          if (filtersContainer) {
            filtersContainer.style.display = 'flex';
          }
          const selectedFiltersContainer = document.getElementById('selectedFiltersContainer');
          if (selectedFiltersContainer) {
            selectedFiltersContainer.style.display = 'none';
            selectedFiltersContainer.innerHTML = '';
          }
          updateFilterUI();
          updatePaginationInfo();
          // Keep results section visible in STATE 2, just clear the data
        };

        // Prepare UI for a brand-new search request (clears table)
        const prepareResultsForNewSearch = () => {
          allProducts = [];
          originalProducts = [];
          displayedProductsCount = 0;
          selectedBrands.clear();
          selectedColors.clear();
          if (resultsBody) {
            resultsBody.innerHTML =
              '<div class="results-empty">Searching Miros for matching products...</div>';
          }
          // Keep filters container visible at all times
          const filtersContainer = document.getElementById('filtersContainer');
          if (filtersContainer) {
            filtersContainer.style.display = 'flex';
          }
          const selectedFiltersContainer = document.getElementById('selectedFiltersContainer');
          if (selectedFiltersContainer) {
            selectedFiltersContainer.style.display = 'none';
            selectedFiltersContainer.innerHTML = '';
          }
          updateFilterUI();
          updatePaginationInfo();
        };

        // Helper to create a product card HTML
        const createProductCard = (item) => {
            const {
              productTitle = "-",
              optionId = "-",
              url = "",
              imageUrl = "",
              brand = "",
            } = item;

            const productId = deriveProductIdFromSource(url, optionId);
            
            const imageHtml = imageUrl
              ? `<img src="${imageUrl}" alt="${productTitle}" class="product-card__image" />`
              : '<div class="product-card__image product-card__image--placeholder">No Image</div>';

            const brandHtml = brand 
              ? `<div class="product-card__brand">${brand}</div>` 
              : '';
            
            const linkIconHtml = url
              ? `<a href="${url}" target="_blank" rel="noopener noreferrer" class="product-card__link" title="View product" aria-label="View product">
                  <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15 10.8333V15.8333C15 16.2754 14.8244 16.6993 14.5118 17.0118C14.1993 17.3244 13.7754 17.5 13.3333 17.5H4.16667C3.72464 17.5 3.30072 17.3244 2.98816 17.0118C2.67559 16.6993 2.5 16.2754 2.5 15.8333V6.66667C2.5 6.22464 2.67559 5.80072 2.98816 5.48816C3.30072 5.17559 3.72464 5 4.16667 5H9.16667" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12.5 2.5H17.5V7.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M8.33334 11.6667L17.5 2.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </a>`
              : '';

            return `
              <div class="product-card">
                <div class="product-card__image-wrapper">
                  ${imageHtml}
                </div>
                <div class="product-card__content">
                  ${brandHtml}
                  <div class="product-card__title">${productTitle}</div>
                  <div class="product-card__id">${productId}</div>
                  ${linkIconHtml}
                </div>
              </div>
            `;
        };

        // Render results with infinite scroll support
        const renderResults = (items = [], append = false) => {
          if (!resultsBody) {
            console.error('‚ùå resultsBody element not found!');
            return;
          }

          console.log(`üé® renderResults called with ${items.length} items, append=${append}, allProducts.length=${allProducts.length}`);

          // If no items but we have allProducts, show empty message
          if (!items.length && allProducts.length === 0) {
            console.log('‚ö†Ô∏è No items and no products - showing empty message');
            resultsBody.innerHTML =
              '<div class="results-empty">No results found. Try a different URL, SKU, or product attribute.</div>';
            summariseResults(0);
            return;
          }
          
          // If no items for current page but we have products, show message
          if (!items.length && allProducts.length > 0 && !append) {
            console.log('‚ö†Ô∏è No items to render but products exist - showing empty message');
            resultsBody.innerHTML =
              '<div class="results-empty">No results found. Try a different URL, SKU, or product attribute.</div>';
            summariseResults(allProducts.length);
            return;
          }

          // If appending, add to existing cards
          if (append && items.length > 0) {
            console.log(`‚ûï Appending ${items.length} product cards`);
            const cards = items.map(createProductCard);
            resultsBody.insertAdjacentHTML('beforeend', cards.join(""));
            summariseResults(allProducts.length);
            updatePaginationInfo();
            return;
          }

          // Initial render or full refresh
          if (items.length > 0) {
            console.log(`‚ú® Rendering ${items.length} product cards`);
            
            // Ensure results section is visible before rendering
            if (dashboardResults) {
              dashboardResults.style.display = 'flex';
              dashboardResults.style.opacity = '1';
              dashboardResults.style.transform = 'none';
              dashboardResults.classList.add('visible');
            }
            
            const cards = items.map(createProductCard);
            resultsBody.innerHTML = cards.join("");
            
            // Verify cards were added
            const renderedCards = resultsBody.querySelectorAll('.product-card');
            console.log(`‚úÖ ${renderedCards.length} product cards rendered in DOM`);
            
            summariseResults(allProducts.length);
            updatePaginationInfo();
            
            // Results section already shown at start of search - just ensure it's visible
            if (!hasSearched) {
              showResultsSection();
            }
          } else {
            console.warn('‚ö†Ô∏è renderResults called with empty items array');
          }
        };

        // Merge a batch of products into allProducts (dedup + optional reset)
        const appendUniqueProducts = (items = [], options = {}) => {
          const { reset = false, silent = false } = options;
          if (!Array.isArray(items)) return 0;
          
          const normalized = items
            .filter(Boolean)
            .map((item) => ({
              productTitle: item.productTitle || item.title || item.name || '-',
              optionId: item.optionId || item.option_id || item.itemId || item.item_id || '-',
              url: item.url || item.productUrl || item.product_url || item.uri || '',
              imageUrl: item.imageUrl || item.image_url || item.image || item.img || '',
              brand: item.brand || item.brandName || '',
              color: item.color_name || item.color || item.colour || item.colour_name || '',
            }));
          
          let baseList = reset ? [] : Array.isArray(allProducts) ? [...allProducts] : [];
          const seenKeys = new Set(
            baseList.map((item) => (item.url || item.optionId || '').toLowerCase())
          );
          const deduped = normalized.filter((item) => {
            const key = (item.url || item.optionId || '').toLowerCase();
            if (key && seenKeys.has(key)) {
              return false;
            }
            if (key) {
              seenKeys.add(key);
            }
            return !!(item.productTitle || item.url || item.optionId);
          });
          
          if (reset) {
            allProducts = deduped;
            displayedProductsCount = 0; // Reset displayed count
          } else if (deduped.length) {
            allProducts = [...baseList, ...deduped];
          }
          
          if (reset && deduped.length === 0) {
            allProducts = [];
            displayedProductsCount = 0;
          }
          
          // Store original products for filtering BEFORE any filtering happens
          originalProducts = [...allProducts];
          
          console.log(`üì¶ Products after deduplication: ${allProducts.length} total, ${deduped.length} new`);
          console.log(`üì¶ Original products stored: ${originalProducts.length}`);
          
          // Extract filter options after products are added (before rendering)
          extractFilterOptions();
          
          // Initialize infinite scroll with new products - render immediately
          if (reset || displayedProductsCount === 0) {
            // Ensure we render products immediately after they're added
            if (allProducts.length > 0) {
              console.log(`üöÄ Initializing infinite scroll with ${allProducts.length} products`);
              initializeInfiniteScroll();
            } else {
              // No products, show empty message
              console.warn('‚ö†Ô∏è No products to render');
              if (resultsBody) {
                resultsBody.innerHTML = '<div class="results-empty">No results found. Try a different URL, SKU, or product attribute.</div>';
              }
            }
          } else {
            // If we already have products displayed, just update the count
            // User can scroll to load more
            summariseResults(allProducts.length);
            updatePaginationInfo();
          }
          
          if (!silent) {
              showStatus(`Loaded ${allProducts.length} products successfully!`, "success");
              setTimeout(() => clearStatus(), 2000);
          }
          
          // Log to console for easy debugging
          console.log(`‚úÖ Total products fetched: ${allProducts.length} | New products added: ${deduped.length}`);
          
          return deduped.length;
        };

        // Miros API configuration - API key authentication required
        const MIROS_API_URL = 'https://api.miros.services/graphql';
        const MIROS_INTEGRATION_ID = 'fb97f7d4-fe95-402f-a81a-402cb062eaa3';
        const MIROS_SLOT = 1;
        const MIROS_API_KEY = '0ddbc6c416ae8f61af7079a7892592138e38b9ad5204cf4ec0682b0e8eea16fe';
        // Removed TARGET_PRODUCT_COUNT limit - fetch all available products via API

        // Direct API call to Miros GraphQL (no popup - fills table directly)
        // According to Miros documentation, required headers are:
        // - x-miros-integration: Integration ID
        // - x-miros-key: API Key
        async function callMirosAPI(query, variables) {
          try {
            const requestHeaders = {
                'Content-Type': 'application/json',
                'x-miros-integration': MIROS_INTEGRATION_ID,
                'x-miros-key': MIROS_API_KEY, // API key authentication as per Miros documentation
            };
            
            // Validate API key is present
            if (!MIROS_API_KEY) {
              throw new Error('API key is required. Please configure MIROS_API_KEY.');
            }
            
            // Debug: Log what we're sending (without exposing full API key)
            console.log('API Request Headers:', {
              'x-miros-integration': MIROS_INTEGRATION_ID,
              'x-miros-key': MIROS_API_KEY ? `${MIROS_API_KEY.substring(0, 10)}...` : 'MISSING',
              'Content-Type': 'application/json'
            });
            
            const response = await fetch(MIROS_API_URL, {
              method: 'POST',
              headers: requestHeaders,
              body: JSON.stringify({ query, variables }),
            });

            if (!response.ok) {
              const errorText = await response.text();
              console.error('API Response Error:', {
                status: response.status,
                statusText: response.statusText,
                body: errorText
              });
              throw new Error(`Miros API error (${response.status}): ${errorText}`);
            }

            const data = await response.json();

            if (data.errors) {
              // Log the actual errors from API
              console.error('Miros GraphQL API Errors:', data.errors);
              
              // Check for authentication errors
              const authError = data.errors.find(e => 
                e.message?.toLowerCase().includes('auth') || 
                e.message?.toLowerCase().includes('unauthorized') ||
                e.message?.toLowerCase().includes('api key') ||
                e.message?.toLowerCase().includes('forbidden') ||
                (e.message?.toLowerCase().includes('invalid') && e.message?.toLowerCase().includes('key'))
              );
              
              if (authError) {
                // Show the ACTUAL error message from the API, not a generic one
                throw new Error(`Authentication failed: ${authError.message}. API key is being sent in headers. Please verify the API key is correct and active.`);
              }
              
              // For other errors, show the actual error messages
              throw new Error(`Miros API errors: ${JSON.stringify(data.errors)}`);
            }

            return data.data;
          } catch (error) {
            console.error('Error calling Miros API:', error);
            throw error;
          }
        }

        // Fetch all products via Miros GraphQL API using recommendations query
        // - Uses the 'recommendations' query which gets recommended products based on alias/item_id
        // - Uses search term as 'alias' (customer product ID) to get recommendations
        // - Fetches all available items with pagination
        // - Deduplicates by URL/product ID
        // - Returns all products found
        async function fetchProductsViaAPI(rawValue) {
          if (!MIROS_API_KEY) {
            throw new Error('API key is required. Please configure MIROS_API_KEY.');
          }
          
          const searchText = rawValue?.trim();
          if (!searchText) {
            throw new Error('Search term cannot be empty.');
          }

          const aggregated = [];
          const seenKeys = new Set(); // Track seen products by URL or product ID

          console.log(`Starting API fetch for: "${searchText}"`);

          try {
            // Use the recommendations query with text_query for text-based searches
            // According to Miros documentation, use text_query for searching by text
            // and alias for searching by specific product ID/alias
            console.log('Using recommendations query with text_query...');
            
            // Build the recommendations query matching the example structure
            const recommendationsQuery = `
              query CPSRecommendations($integration_id: String!, $text_query: String!, $text_query_language: String!, $limit: Int!) {
                recommendations(query: {
                  integration_id: $integration_id,
                  text_query: $text_query,
                  text_query_language: $text_query_language,
                  limit: $limit
                }) {
                  id
                  alias
                  name
                  url
                  image
                  brand
                  category_id
                  color_name
                  price
                  price_discounted
                  score
                }
              }
            `;
            
            console.log('Built recommendations query:', recommendationsQuery);
            console.log(`Fetching recommendations for text query: "${searchText}"...`);
            
            // Execute the recommendations query
            // Use text_query for text-based searches (not alias, which is for product IDs)
            // Fetch up to 5,000 products in a single request (reduced from 10,000 to avoid server errors)
            const maxProductsToFetch = 5000;
            
            console.log(`Fetching up to ${maxProductsToFetch} recommendations...`);
            
            try {
              const data = await callMirosAPI(recommendationsQuery, {
                integration_id: MIROS_INTEGRATION_ID,
                text_query: searchText, // Use search term as text_query for text searches
                text_query_language: "en", // Set language to English
                limit: maxProductsToFetch // Request up to 5,000 products
              });

              const recommendations = data?.recommendations || [];
              console.log(`Received ${recommendations.length} recommendations from API`);

              if (!recommendations.length) {
                console.log('No recommendations available.');
              } else {
                // Process and deduplicate recommendations
                let newItemsCount = 0;
                let duplicateCount = 0;
                
                for (const item of recommendations) {
                  // Transform to our format (recommendations returns: id, alias, name, url, image, brand, etc.)
                  const normalized = {
                    productTitle: item.name || item.alias || '-',
                    optionId: item.id || item.alias || '-',
                    url: item.url || '',
                    imageUrl: item.image || item.image_optimized || '',
                    brand: item.brand || '',
                    color: item.color_name || item.color || '',
                  };
                  
                  const key = (normalized.url || normalized.optionId || '').toLowerCase().trim();
                  
                  if (!key || key === '-') {
                    console.warn('Skipping item with no URL or product ID:', normalized);
                    continue;
                  }
                  
                  if (seenKeys.has(key)) {
                    duplicateCount++;
                    continue;
                  }
                  
                  seenKeys.add(key);
                  aggregated.push(normalized);
                  newItemsCount++;
                }
                
                console.log(`Added ${newItemsCount} new items, skipped ${duplicateCount} duplicates`);
                console.log(`Total unique products: ${aggregated.length}`);
              }
            } catch (error) {
              console.error(`Error fetching recommendations:`, error);
              // If we have some results, return them
              if (aggregated.length > 0) {
                console.warn(`Returning ${aggregated.length} products despite error`);
              } else {
                // If no results yet, throw the error
                throw error;
              }
            }
            
            console.log(`‚úÖ Recommendations fetch complete: ${aggregated.length} unique products found (max: ${maxProductsToFetch})`);
            
            if (aggregated.length === 0) {
              throw new Error('No recommendations returned from API. Try a different search term or check if products exist in the Miros database.');
            }
            
            return aggregated;
            
          } catch (error) {
            console.error(`Error fetching recommendations:`, error);
            // If we have some results, return what we have
            if (aggregated.length > 0) {
              console.warn(`Returning ${aggregated.length} products despite error`);
              return aggregated;
            }
            // If no results yet, throw the error
            throw error;
          }
        }

        // Introspect GraphQL schema - SIMPLIFIED to avoid "Maximum introspection depth exceeded"
        async function introspectMirosSchema() {
          // This function is no longer used - we use recommendations query directly
          // Keeping it for potential future use
          return null;
        }

        // Transform Miros result / scraped item to table format
        function transformMirosResult(item) {
          // Handle various field name variations from the API
          // The API might return different field names, so we check multiple possibilities
          return {
            productTitle: item.productTitle || item.title || item.name || item.text || item.label || item.value || '-',
            optionId: item.optionId || item.option_id || item.itemId || item.item_id || item.id || item._id || '-',
            url: item.url || item.productUrl || item.product_url || item.uri || item.link || item.href || '',
            imageUrl: item.imageUrl || item.image_url || item.image || item.img || item.imageUrl || item.thumbnail || '',
            brand: item.brand || item.brandName || '',
            color: item.color_name || item.color || item.colour || item.colour_name || '',
          };
        }

        // REMOVED: scrapeMirosOverlayIntoTable - DOM scraping method removed, using API only
        // This function has been completely removed - API-only fetching is now used
        async function scrapeMirosOverlayIntoTable() {
          console.warn('DOM scraping method has been removed. Using API-only fetching.');
          return false;
        }
        
        // REMOVED: All DOM scraping code below has been removed
        /*
          console.log('=== Starting Miros overlay scraping ===');
          
          // SIMPLIFIED: Find the overlay/modal directly
          let container = null;
          
          // Method 1: Look for visible dialog/modal (most common)
          const visibleDialogs = Array.from(document.querySelectorAll('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]'))
            .filter(d => {
              // CRITICAL: Exclude our own focus overlay
              if (d.id === 'focusOverlay' || d.classList.contains('focus-overlay')) {
                return false;
              }
              const style = window.getComputedStyle(d);
              return style.display !== 'none' && style.visibility !== 'hidden' && style.opacity !== '0';
            });
          
          if (visibleDialogs.length > 0) {
            // Prefer dialogs that contain Miros elements or product links
            const mirosDialog = visibleDialogs.find(d => 
              d.querySelector('[id*="miros"], [class*="miros"], [data-miros], a[href*="/p/"]')
            );
            container = mirosDialog || visibleDialogs[0];
            console.log('Found visible dialog/modal:', container.id || container.className);
          }
          
          // Method 2: Look for Miros-specific containers
          if (!container) {
            const mirosContainers = [
              '#miros-recommendations',
              '[id*="miros-recommendations"]',
              '[id*="miros"][id*="overlay"]',
              '[id*="miros"][id*="modal"]',
              '[class*="miros-overlay"]',
              '[class*="miros-modal"]',
            ];
            
            for (const selector of mirosContainers) {
              const elements = document.querySelectorAll(selector);
              for (const el of elements) {
                // Exclude our own elements
                if (el.id === 'focusOverlay' || el.classList.contains('focus-overlay')) continue;
                
                const style = window.getComputedStyle(el);
                if (style.display !== 'none' && style.visibility !== 'hidden') {
                  // Check if it has product links or Miros content
                  if (el.querySelector('a[href*="/p/"], [id*="miros"], [class*="miros"]')) {
                container = el;
                    console.log('Found Miros container with content:', selector);
                break;
              }
                }
              }
              if (container) break;
            }
          }
          
          // Method 3: Look for dialogs/modals that contain product links
          if (!container) {
            const allDialogs = document.querySelectorAll('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]');
            for (const dialog of allDialogs) {
              // Exclude our focus overlay
              if (dialog.id === 'focusOverlay' || dialog.classList.contains('focus-overlay')) continue;
              
              const style = window.getComputedStyle(dialog);
              if (style.display !== 'none' && style.visibility !== 'hidden') {
                // Check if it has product links
                const hasProductLinks = dialog.querySelector('a[href*="/p/"]');
                if (hasProductLinks) {
                  container = dialog;
                  console.log('Found dialog with product links:', dialog.id || dialog.className);
                  break;
                }
              }
            }
          }
          
          // Method 4: Fallback to body
          if (!container) {
            container = document.body;
            console.log('Using document.body as container');
          }

          // SIMPLIFIED: Find product images (they're the most reliable indicator)
          const allImages = container.querySelectorAll('img[src]');
          console.log(`Found ${allImages.length} images in container`);
          
          // Filter to product images (exclude logos, icons, small images)
          const productImages = Array.from(allImages).filter(img => {
            const src = img.src || img.getAttribute('src') || '';
            const alt = img.alt || '';
            const width = img.naturalWidth || img.width || 0;
            const height = img.naturalHeight || img.height || 0;
            
            // Exclude very small images (likely icons)
            if (width > 0 && width < 100) return false;
            if (height > 0 && height < 100) return false;
            
            // Exclude logos and icons
            if (alt.toLowerCase().includes('logo') || alt.toLowerCase().includes('icon')) return false;
            if (src.includes('logo') || src.includes('icon')) return false;
            
            // Must be in a card-like container or have meaningful parent
            const parent = img.closest('[role="listitem"], [class*="card"], [class*="item"], a');
            if (!parent) return false;
            
            // Must have some text nearby (product title)
            const hasText = parent.textContent && parent.textContent.trim().length > 10;
            
            return hasText;
          });
          
          console.log(`Filtered to ${productImages.length} product images`);
          
          if (productImages.length === 0) {
            console.warn('No product images found. Trying to find product links directly...');
            // Fallback: try to find product links
            const productLinks = container.querySelectorAll('a[href*="/p/"]');
            const validLinks = Array.from(productLinks).filter(link => {
              const href = link.href || link.getAttribute('href') || '';
              return href.includes('/p/') && href.includes('centrepointstores.com');
            });
            
            if (validLinks.length > 0) {
              console.log(`Found ${validLinks.length} product links, using those`);
              
              // Sort links by visual position (top to bottom, left to right)
              const sortedLinks = Array.from(validLinks).sort((a, b) => {
                const rectA = a.getBoundingClientRect();
                const rectB = b.getBoundingClientRect();
                const topDiff = rectA.top - rectB.top;
                if (Math.abs(topDiff) > 50) {
                  return topDiff;
                }
                return rectA.left - rectB.left;
              });
              
              // Convert links to "cards" for processing
              const items = sortedLinks.map(link => {
                const img = link.querySelector('img[src]');
                const text = link.textContent?.trim() || img?.alt || '';
                const url = link.href || link.getAttribute('href') || '';
                const imageUrl = img ? (img.src || img.getAttribute('src') || '') : '';
                const match = url.match(/\/p\/([^?]+)/);
                const optionId = match ? match[1] : '-';
                
                return {
                  productTitle: text.length > 10 ? text.substring(0, 150) : 'Product',
                  optionId: optionId,
                  url: url,
                  imageUrl: imageUrl,
                };
              });
              
              // Store all products and initialize infinite scroll
              allProducts = items;
              displayedProductsCount = 0;
              initializeInfiniteScroll();
              return items.length > 0;
            }
            
            console.error('No products found at all. Container:', container.id || container.className);
            // Show empty results
            renderResults([]);
            return false;
          }

          console.log(`Processing ${productImages.length} product cards`);
          
          // Sort product images by visual position (top to bottom, left to right)
          const sortedImages = Array.from(productImages).sort((a, b) => {
            const rectA = a.getBoundingClientRect();
            const rectB = b.getBoundingClientRect();
            // First sort by top position (y-coordinate)
            const topDiff = rectA.top - rectB.top;
            if (Math.abs(topDiff) > 50) { // If difference is significant (different row)
              return topDiff;
            }
            // If in same row, sort by left position (x-coordinate)
            return rectA.left - rectB.left;
          });
          
          // Helper function to extract URL from modal after clicking (async)
          const extractUrlFromModal = async (card, productContainer) => {
            return new Promise((resolve) => {
              // Try clicking the card to open modal
              try {
                card.click();
                
                // Wait for modal to appear
                setTimeout(() => {
                  // Look for "View details" button in modal
                  const modal = document.querySelector('[role="dialog"], .modal, [class*="modal"], [class*="overlay"]');
                  if (modal) {
                    const viewDetailsBtn = Array.from(modal.querySelectorAll('button, a')).find(btn => {
                      const text = btn.textContent?.toLowerCase() || '';
                      return text.includes('view details');
                    });
                    
                    if (viewDetailsBtn) {
                      const url = viewDetailsBtn.href || 
                                 viewDetailsBtn.getAttribute('href') ||
                                 viewDetailsBtn.getAttribute('data-href') ||
                                 '';
                      if (url && url.includes('/p/')) {
                        // Close modal
                        const closeBtn = modal.querySelector('[aria-label*="close" i], [class*="close"], button[aria-label*="√ó"]');
                        if (closeBtn) closeBtn.click();
                        resolve(url);
                        return;
                      }
                    }
                    
                    // Close modal if we opened it
                    const closeBtn = modal.querySelector('[aria-label*="close" i], [class*="close"], button[aria-label*="√ó"]');
                    if (closeBtn) closeBtn.click();
                  }
                  resolve('');
                }, 500);
              } catch (e) {
                resolve('');
              }
            });
          };

          // Extract data from product images (using sorted order)
          const items = sortedImages.map((productImg, index) => {
            // Find the card container (parent with the most info)
            const card = productImg.closest('[role="listitem"], [class*="card"], [class*="item"], a') || productImg.parentElement;
            // Find the actual product container
            let productContainer = card.closest('[role="listitem"], [class*="card"], [class*="item"]') || card;
            
            // Use the product image we already found
            const img = productImg;
            const imageUrl = img.src || img.getAttribute('src') || '';
            
            // Find product title element (the red highlighted box)
            // Try common title selectors - look for the main text in the card
            let titleEl = null;
            const titleSelectors = [
              'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
              '[class*="title"]',
              '[class*="product-title"]',
              '[class*="name"]',
              '[data-title]',
              'p[class*="title"]',
              'span[class*="title"]',
              'div[class*="title"]'
            ];
            
            for (const selector of titleSelectors) {
              titleEl = productContainer.querySelector(selector) || card.querySelector(selector);
              if (titleEl && titleEl.textContent && titleEl.textContent.trim().length > 10) {
                break;
              }
            }
            
            // If no title element found, look for the longest text node that's not price/brand/button text
            if (!titleEl || !titleEl.textContent || titleEl.textContent.trim().length < 10) {
              const allTextElements = productContainer.querySelectorAll('p, span, div, a, h1, h2, h3, h4, h5, h6');
              let longestText = '';
              for (const el of allTextElements) {
                const text = el.textContent?.trim() || '';
                // Skip if it's too short, is a price (AED/$, numbers), or is button text
                if (text.length > longestText.length && 
                    text.length > 10 && 
                    text.length < 200 &&
                    !text.match(/^AED\s*\d+/) &&
                    !text.match(/^\$\d+/) &&
                    !text.match(/^\d+$/) &&
                    !text.toLowerCase().includes('view details') &&
                    !text.toLowerCase().includes('add to') &&
                    !text.toLowerCase().includes('basket') &&
                    !text.toLowerCase().includes('cart')) {
                  longestText = text;
                  titleEl = el;
                }
              }
            }
            
            // Extract product title from title element
            let productTitle = '-';
            if (titleEl && titleEl.textContent) {
              productTitle = titleEl.textContent.trim();
              // Clean up title - remove price, brand prefixes if they're in the same text
              productTitle = productTitle
                .replace(/AED\s*\d+.*$/i, '')
                .replace(/^\$\d+.*$/i, '')
                .replace(/^\d+.*$/i, '')
                .trim();
            }
            
            // Fallback to image alt text
            if ((productTitle === '-' || productTitle.length < 10) && img) {
              const alt = img.getAttribute('alt') || '';
              if (alt && alt.length > 10) {
                productTitle = alt.trim();
              }
            }
            
            // Find product URL - look for "View details" link or product link
            let url = '';
            
            // Method 1: Look for buttons/links with "View details" text (case insensitive)
            const allButtons = productContainer.querySelectorAll('button, a');
            for (const btn of allButtons) {
              const text = btn.textContent?.toLowerCase() || '';
              if (text.includes('view details') || text.includes('view') && text.includes('details')) {
                url = btn.href || 
                      btn.getAttribute('href') ||
                      btn.getAttribute('data-href') ||
                      btn.getAttribute('onclick')?.match(/href['"]?\s*[:=]\s*['"]([^'"]+)/)?.[1] ||
                      '';
                if (url && url.includes('/p/')) {
                  break;
                }
              }
            }
            
            // Method 2: Look for any link/button with /p/ pattern in the card
            if (!url || !url.includes('/p/')) {
              const viewDetailsLink = productContainer.querySelector('a[href*="/p/"], button[data-href*="/p/"], a[href*="centrepointstores.com"][href*="/p/"]') ||
                                     card.querySelector('a[href*="/p/"], button[data-href*="/p/"]');
              
              if (viewDetailsLink) {
                url = viewDetailsLink.href || 
                      viewDetailsLink.getAttribute('href') ||
                      viewDetailsLink.getAttribute('data-href') ||
                      '';
              }
            }
            
            // Method 3: Check if card itself is a link or has data-url
            if (!url || !url.includes('/p/')) {
              if (card.tagName === 'A' && card.href && card.href.includes('/p/')) {
                url = card.href;
              } else {
                url = card.getAttribute('href') ||
                      card.getAttribute('data-url') ||
                      card.getAttribute('data-href') ||
                      card.getAttribute('data-product-url') ||
                      productContainer.getAttribute('href') ||
                      productContainer.getAttribute('data-url') ||
                      productContainer.getAttribute('data-href') ||
                      productContainer.getAttribute('data-product-url') ||
                      '';
              }
            }
            
            // Method 4: Look for any link in the container with /p/ pattern
            if (!url || !url.includes('/p/')) {
              const allLinks = productContainer.querySelectorAll('a[href]');
              for (const link of allLinks) {
                const href = link.href || link.getAttribute('href') || '';
                if (href.includes('/p/') && href.includes('centrepointstores.com')) {
                  url = href;
                  break;
                }
              }
            }
            
            // Method 5: Check data attributes for product ID and construct URL
            if (!url || !url.includes('/p/')) {
              const productId = card.getAttribute('data-product-id') ||
                               card.getAttribute('data-item-id') ||
                               card.getAttribute('miros-data-id') ||
                               card.getAttribute('data-id') ||
                               productContainer.getAttribute('data-product-id') ||
                               productContainer.getAttribute('data-item-id') ||
                               productContainer.getAttribute('data-id');
              
              if (productId && productId.match(/^\d+$/)) {
                url = `https://www.centrepointstores.com/ae/en/p/${productId}`;
              }
            }
            
            // Method 6: If still no URL, check if clicking is needed (but don't auto-click all at once - too disruptive)
            // This will be handled separately if needed - for now, we'll extract what we can without clicking
            
            // Extract product ID from URL (/p/... format - can be numeric, alphanumeric, or mixed)
            let optionId = '-';
            if (url && url.includes('/p/')) {
              const match = url.match(/\/p\/([^?]+)/);
              if (match && match[1]) {
                optionId = match[1];
              }
            }
            
            // Try other ID sources if URL didn't work
            if (optionId === '-') {
              optionId = card.getAttribute('miros-data-id') || 
                        card.getAttribute('data-miros-id') ||
                        card.getAttribute('data-item-id') ||
                        productContainer.getAttribute('miros-data-id') ||
                        productContainer.getAttribute('data-miros-id') ||
                        productContainer.getAttribute('data-item-id') ||
                        '';
              
              // Exclude layout IDs
              if (optionId && (optionId.includes('masonry') || optionId.includes('container') || optionId.includes('wrapper'))) {
                optionId = '-';
              }
            }

            // Extract category info
            const superCategory = 
              card.getAttribute('data-category') || 
              productContainer.getAttribute('data-category') ||
              card.getAttribute('data-miros-category') ||
              '-';
            
            const department = 
              card.getAttribute('data-department') || 
              productContainer.getAttribute('data-department') ||
              '-';

            // Log what we extracted for debugging
            if (index < 3) {
              console.log(`Product ${index + 1}:`, {
                title: productTitle,
                titleElement: titleEl?.tagName || 'none',
                titleText: titleEl?.textContent?.substring(0, 50) || 'none',
                optionId: optionId,
                url: url,
                hasImg: !!img,
                imgSrc: img?.src?.substring(0, 50) || 'none'
              });
            }

            return {
              productTitle: productTitle || `Product ${index + 1}`,
              optionId: optionId || `${index + 1}`,
              url: url || '-',
              imageUrl: imageUrl || '',
            };
          });

          console.log('Scraped items from Miros overlay:', items);
          
          appendUniqueProducts(items, { reset: allProducts.length === 0, silent: true });
          
          // Enhanced scrolling to fetch all available items from overlay
          // Continue fetching until no more items are available
          const shouldContinueFetching = true; // Always try to fetch more from overlay
          if (shouldContinueFetching) {
            const targetItems = Infinity; // No limit - fetch all available
            const maxScrollAttempts = 100; // Increased from 25 - allow more scrolling to get all products
            let scrollAttempts = 0;
            const scrollDelay = 3000; // Increased from 2000 - wait longer for products to load
            let isScrolling = false;
            let previousProductCount = allProducts.length; // Track previous count to detect when no new products found
            
            // Find the scrollable container with better detection
            const findScrollableContainer = () => {
              // Try multiple selectors for scrollable containers
              const selectors = [
                '[style*="overflow"]',
                '[class*="scroll"]',
                '[class*="grid"]',
                '[class*="masonry"]',
                '[class*="list"]',
                '[class*="container"]',
                '[data-scroll]'
              ];
              
              for (const selector of selectors) {
                const elements = container.querySelectorAll(selector);
                for (const el of elements) {
                  const style = window.getComputedStyle(el);
                  if (el.scrollHeight > el.clientHeight && 
                      (style.overflow === 'auto' || style.overflow === 'scroll' || 
                       style.overflowY === 'auto' || style.overflowY === 'scroll' ||
                       style.overflowX === 'auto' || style.overflowX === 'scroll')) {
                    return el;
                  }
                }
              }
              
              // Fallback: check container itself and parent elements
              let current = container;
              for (let i = 0; i < 5 && current; i++) {
                if (current.scrollHeight > current.clientHeight) {
                  return current;
                }
                current = current.parentElement;
              }
              
            return null;
            };
            
            const scrollableContainer = findScrollableContainer();
            
            if (scrollableContainer) {
              console.log('Found scrollable container, attempting to load 100+ items...');
              console.log('Container dimensions:', {
                scrollHeight: scrollableContainer.scrollHeight,
                clientHeight: scrollableContainer.clientHeight,
                scrollTop: scrollableContainer.scrollTop
              });
              
              // Function to extract ALL products from DOM (search entire container, not just scrollableContainer)
              const extractAllProductsFromDOM = () => {
                // Search in the entire container AND document body to find all products
                const searchContainers = [container, document.body];
                const allImages = [];
                
                searchContainers.forEach(searchContainer => {
                  const images = searchContainer.querySelectorAll('img[src]');
                  allImages.push(...Array.from(images));
                });
                
                console.log(`Found ${allImages.length} total images across all containers`);
                
                const allProductImages = Array.from(allImages).filter(img => {
                  const src = img.src || img.getAttribute('src') || '';
                  const alt = img.alt || '';
                  const width = img.naturalWidth || img.width || 0;
                  const height = img.naturalHeight || img.height || 0;
                  
                  if (width > 0 && width < 100) return false;
                  if (height > 0 && height < 100) return false;
                  if (alt.toLowerCase().includes('logo') || alt.toLowerCase().includes('icon')) return false;
                  if (src.includes('logo') || src.includes('icon')) return false;
                  
                  const parent = img.closest('[role="listitem"], [class*="card"], [class*="item"], a');
                  if (!parent) return false;
                  
                  const hasText = parent.textContent && parent.textContent.trim().length > 10;
                  return hasText;
                });
                
                console.log(`Filtered to ${allProductImages.length} product images`);
                
                // Sort by visual position
                const sortedImages = Array.from(allProductImages).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  const topDiff = rectA.top - rectB.top;
                  if (Math.abs(topDiff) > 50) return topDiff;
                  return rectA.left - rectB.left;
                });
                
                // Extract ALL product data (we'll filter duplicates later)
                const allItems = sortedImages.map((productImg) => {
                  const card = productImg.closest('[role="listitem"], [class*="card"], [class*="item"], a') || productImg.parentElement;
                  const productContainer = card.closest('[role="listitem"], [class*="card"], [class*="item"]') || card;
                  const img = productImg;
                  const imageUrl = img.src || img.getAttribute('src') || '';
                  
                  const titleEl = productContainer.querySelector('h1, h2, h3, h4, h5, h6, [class*="title"], [class*="name"]') || 
                                 Array.from(productContainer.querySelectorAll('p, span, div')).find(el => {
                                   const text = el.textContent?.trim() || '';
                                   return text.length > 10 && text.length < 200 && !text.match(/^AED\s*\d+/) && !text.match(/^\$\d+/);
                                 });
                  const productTitle = titleEl?.textContent?.trim() || img.getAttribute('alt') || '-';
                  
                  const linkEl = productContainer.querySelector('a[href*="/p/"]') || card.querySelector('a[href*="/p/"]');
                  const url = linkEl?.href || linkEl?.getAttribute('href') || '';
                  
                  if (!url || url === '-' || !url.includes('/p/')) return null;
                  
                  const match = url.match(/\/p\/([^?]+)/);
                  const optionId = match ? match[1] : '-';
                  
                  return {
                    productTitle: productTitle || `Product`,
                    optionId: optionId,
                    url: url,
                    imageUrl: imageUrl || '',
                  };
                }).filter(item => item !== null && item.url !== '-');
                
                // Filter duplicates by URL to get unique items
                const uniqueItems = [];
                const seenUrls = new Set();
                for (const item of allItems) {
                  if (!seenUrls.has(item.url)) {
                    seenUrls.add(item.url);
                    uniqueItems.push(item);
                  }
                }
                
                console.log(`Extracted ${uniqueItems.length} unique products from DOM`);
                return uniqueItems;
              };
              
              // Function to update products list with all extracted items (NO UI UPDATE - just store data)
              const updateProductsList = () => {
                const allExtracted = extractAllProductsFromDOM();
                
                if (allExtracted.length > allProducts.length) {
                  allProducts = allExtracted; // Replace with all items (no duplicates)
                  console.log(`‚úÖ Updated: Total products now: ${allProducts.length}`);
                  
                  // Show progress in status message only (NO table update until done)
                  showStatus(`Fetching products from overlay... (${allProducts.length} products fetched)`, "pending");
                  
                  return true;
                } else if (allExtracted.length === allProducts.length) {
                  console.log(`No new items found. Current total: ${allProducts.length}`);
                  return false;
                }
                
                return false;
              };
              
              // Multiple extraction passes to catch all initially visible products
              console.log('Running multiple extraction passes to catch all visible products...');
              for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                  const allExtracted = extractAllProductsFromDOM();
                  if (allExtracted.length > allProducts.length) {
                    const previousCount = allProducts.length;
                    allProducts = allExtracted;
                    console.log(`Extraction pass ${i + 1}: Found ${allProducts.length} products (was ${previousCount})`);
                    updatePaginationInfo();
                  }
                }, i * 1000); // Extract at 0s, 1s, 2s
              }
              
              // Function to show loading state in table
              const showLoadingInTable = () => {
                const resultsBody = document.getElementById('resultsBody');
                if (resultsBody) {
                  resultsBody.innerHTML = `<div class="results-empty" style="text-align: center; padding: 40px;">
                    <div style="font-size: 16px; color: var(--text-secondary); margin-bottom: 10px;">
                      Loading products from overlay...
                    </div>
                    <div style="font-size: 14px; color: var(--text-muted);">
                      ${allProducts.length} products fetched
                    </div>
                  </div>`;
                }
              };
              
              // Use MutationObserver to detect when new items are loaded
              const observer = new MutationObserver((mutations) => {
                if (isScrolling) return; // Prevent concurrent processing
                
                const hasNewContent = mutations.some(mutation => {
                  return mutation.addedNodes.length > 0;
                });
                
                if (hasNewContent) {
                  // Wait longer for content to fully render
                  setTimeout(() => {
                    updateProductsList();
                    showLoadingInTable(); // Update loading message
                    isScrolling = false;
                  }, 2000); // Increased from 1000ms to 2000ms
                }
              });
              
              // Start observing both scrollableContainer and container
              observer.observe(scrollableContainer, {
                childList: true,
                subtree: true
              });
              observer.observe(container, {
                childList: true,
                subtree: true
              });
              
              // Show loading state in table immediately
              showLoadingInTable();
              
              // Start scrolling process
              const scrollInterval = setInterval(() => {
                // Check if we've reached max attempts or no more content
                if (scrollAttempts >= maxScrollAttempts) {
                  clearInterval(scrollInterval);
                  observer.disconnect();
                  console.log(`‚ö†Ô∏è Max attempts reached. Total items: ${allProducts.length}`);
                  
                  // Final extraction
                  updateProductsList();
                  
                  // NOW update UI with all products we found
                  displayedProductsCount = 0;
                  initializeInfiniteScroll();
                  
                  // Close overlay
                  setTimeout(() => {
                    closeMirosOverlay();
                    showStatus(`Loaded ${allProducts.length} products (max attempts reached)`, "info");
                    setTimeout(() => clearStatus(), 2000);
                  }, 500);
                  
                  return;
                }
                
                if (isScrolling) return; // Skip if already processing
                isScrolling = true;
                
                const previousScrollTop = scrollableContainer.scrollTop;
                const previousScrollHeight = scrollableContainer.scrollHeight;
                previousProductCount = allProducts.length; // Track product count before scrolling
                
                // Scroll to bottom
                scrollableContainer.scrollTop = scrollableContainer.scrollHeight;
                scrollAttempts++;
                
                // Update status and loading table
                showStatus(`Fetching products from overlay... (${allProducts.length} products fetched)`, "pending");
                showLoadingInTable();
                
                console.log(`üìú Scroll attempt ${scrollAttempts}/${maxScrollAttempts}, current items: ${allProducts.length}`);
                
                // Check if we've reached the end (scroll position didn't change)
                // Wait longer for content to load (increased from 800ms to 3000ms)
                setTimeout(() => {
                  const newScrollHeight = scrollableContainer.scrollHeight;
                  const newScrollTop = scrollableContainer.scrollTop;
                  
                  if (newScrollTop === previousScrollTop && newScrollHeight === previousScrollHeight) {
                    // Reached end - but wait a bit more in case content loads slowly
                    console.log('‚ö†Ô∏è Reached end of scrollable content, waiting additional time...');
                      setTimeout(() => {
                        updateProductsList();
                      // If still no new products after waiting, we're done
                      if (allProducts.length === previousProductCount) {
                        console.log('‚úÖ No new products found after additional wait - truly at end');
                        clearInterval(scrollInterval);
                        observer.disconnect();
                        
                        // Final update to ensure all items are captured
                        displayedProductsCount = 0;
                        initializeInfiniteScroll();
                      
                      setTimeout(() => {
                        closeMirosOverlay();
                        showStatus(`Successfully loaded ${allProducts.length} products!`, "success");
                        setTimeout(() => clearStatus(), 2000);
                      }, 500);
                        return;
                      }
                      isScrolling = false;
                    }, 2000); // Additional 2 second wait
                    return;
                  }
                  
                    // New content might be loading, extract after delay
                    setTimeout(() => {
                      updateProductsList();
                      showLoadingInTable(); // Update loading message
                    
                    // Check if we found new products
                    if (allProducts.length > previousProductCount) {
                      console.log(`‚úÖ Found ${allProducts.length - previousProductCount} new products (total: ${allProducts.length})`);
                    } else {
                      console.log(`‚ö†Ô∏è No new products found this scroll (still ${allProducts.length})`);
                    }
                    
                    isScrolling = false;
                  }, 2000); // Wait 2 seconds for content to fully render (increased from 1500ms)
                }, 3000); // Increased from 800ms to 3000ms - wait longer for products to load
              }, scrollDelay);
              
              // Initial extraction and first scroll
              setTimeout(() => {
                // Do initial extraction
                updateProductsList();
                showLoadingInTable();
                
                // Then scroll
                scrollableContainer.scrollTop = scrollableContainer.scrollHeight;
                
                // Extract again after scroll
                setTimeout(() => {
                  updateProductsList();
                  showLoadingInTable();
                }, 2000);
              }, 1000);
              
            } else {
              console.warn('No scrollable container found. Attempting to extract all items from container...');
              
              // Show loading state
              const resultsBody = document.getElementById('resultsBody');
              if (resultsBody) {
                resultsBody.innerHTML = `<tr><td colspan="4" class="results-empty" style="text-align: center; padding: 40px;">
                  <div style="font-size: 16px; color: var(--text-secondary); margin-bottom: 10px;">
                    Loading products from overlay...
                  </div>
                  <div style="font-size: 14px; color: var(--text-muted);">
                    ${allProducts.length} products fetched
                  </div>
                </td></tr>`;
              }
              
              // Still try to extract all products from the container
              const extractAllProductsFromDOM = () => {
                // Search in the entire container AND document body to find all products
                const searchContainers = [container, document.body];
                const allImages = [];
                
                searchContainers.forEach(searchContainer => {
                  const images = searchContainer.querySelectorAll('img[src]');
                  allImages.push(...Array.from(images));
                });
                
                console.log(`Found ${allImages.length} total images across all containers`);
                
                const allProductImages = Array.from(allImages).filter(img => {
                  const src = img.src || img.getAttribute('src') || '';
                  const alt = img.alt || '';
                  const width = img.naturalWidth || img.width || 0;
                  const height = img.naturalHeight || img.height || 0;
                  
                  if (width > 0 && width < 100) return false;
                  if (height > 0 && height < 100) return false;
                  if (alt.toLowerCase().includes('logo') || alt.toLowerCase().includes('icon')) return false;
                  if (src.includes('logo') || src.includes('icon')) return false;
                  
                  const parent = img.closest('[role="listitem"], [class*="card"], [class*="item"], a');
                  if (!parent) return false;
                  
                  const hasText = parent.textContent && parent.textContent.trim().length > 10;
                  return hasText;
                });
                
                const sortedImages = Array.from(allProductImages).sort((a, b) => {
                  const rectA = a.getBoundingClientRect();
                  const rectB = b.getBoundingClientRect();
                  const topDiff = rectA.top - rectB.top;
                  if (Math.abs(topDiff) > 50) return topDiff;
                  return rectA.left - rectB.left;
                });
                
                const allItems = sortedImages.map((productImg) => {
                  const card = productImg.closest('[role="listitem"], [class*="card"], [class*="item"], a') || productImg.parentElement;
                  const productContainer = card.closest('[role="listitem"], [class*="card"], [class*="item"]') || card;
                  const img = productImg;
                  const imageUrl = img.src || img.getAttribute('src') || '';
                  
                  const titleEl = productContainer.querySelector('h1, h2, h3, h4, h5, h6, [class*="title"], [class*="name"]') || 
                                 Array.from(productContainer.querySelectorAll('p, span, div')).find(el => {
                                   const text = el.textContent?.trim() || '';
                                   return text.length > 10 && text.length < 200 && !text.match(/^AED\s*\d+/) && !text.match(/^\$\d+/);
                                 });
                  const productTitle = titleEl?.textContent?.trim() || img.getAttribute('alt') || '-';
                  
                  const linkEl = productContainer.querySelector('a[href*="/p/"]') || card.querySelector('a[href*="/p/"]');
                  const url = linkEl?.href || linkEl?.getAttribute('href') || '';
                  
                  if (!url || url === '-' || !url.includes('/p/')) return null;
                  
                  const match = url.match(/\/p\/([^?]+)/);
                  const optionId = match ? match[1] : '-';
                  
                  return {
                    productTitle: productTitle || `Product`,
                    optionId: optionId,
                    url: url,
                    imageUrl: imageUrl || '',
                  };
                }).filter(item => item !== null && item.url !== '-');
                
                const uniqueItems = [];
                const seenUrls = new Set();
                for (const item of allItems) {
                  if (!seenUrls.has(item.url)) {
                    seenUrls.add(item.url);
                    uniqueItems.push(item);
                  }
                }
                
                console.log(`Extracted ${uniqueItems.length} unique products from container`);
                return uniqueItems;
              };
              
              // Try multiple times to extract all products
              let extractionAttempts = 0;
              const maxExtractionAttempts = 20; // Increased from 5 - try more times to catch all products
              const extractionInterval = setInterval(() => {
                extractionAttempts++;
                const allExtracted = extractAllProductsFromDOM();
                
                if (allExtracted.length > allProducts.length) {
                  allProducts = allExtracted;
                  console.log(`Updated products: ${allProducts.length}`);
                  
                  // Update loading message
                  showStatus(`Fetching products from overlay... (${allProducts.length} products fetched)`, "pending");
                  if (resultsBody) {
                    resultsBody.innerHTML = `<div class="results-empty" style="text-align: center; padding: 40px;">
                      <div style="font-size: 16px; color: var(--text-secondary); margin-bottom: 10px;">
                        Loading products from overlay...
                      </div>
                      <div style="font-size: 14px; color: var(--text-muted);">
                        ${allProducts.length}/${targetItems} products fetched
                      </div>
                    </div>`;
                  }
                }
                
                if (extractionAttempts >= maxExtractionAttempts) {
                  clearInterval(extractionInterval);
                  
                  // NOW update UI with all products
                  displayedProductsCount = 0;
                  initializeInfiniteScroll();
                  
                  setTimeout(() => {
                    closeMirosOverlay();
                    showStatus(`Successfully loaded ${allProducts.length} products!`, "success");
                    setTimeout(() => clearStatus(), 2000);
                  }, 500);
                }
              }, 2000);
            }
          } else {
            // If we already have items, render immediately and close overlay
            displayedProductsCount = 0;
            initializeInfiniteScroll();
            
            setTimeout(() => {
              closeMirosOverlay();
              showStatus(`Successfully loaded ${allProducts.length} products!`, "success");
              setTimeout(() => clearStatus(), 2000);
            }, 500);
          }
          
          return items.length > 0;
        }
        */
        
        // Load more products when scrolling near bottom
        // Load more products when scrolling near bottom
        // Progressive loading: displays 50 products at a time as user scrolls
        // All products (up to 5,000) are fetched upfront but displayed progressively
        function loadMoreProducts() {
          if (isLoadingMore) return;
          if (displayedProductsCount >= allProducts.length) {
            updatePaginationInfo();
            return; // All products already displayed
          }

          isLoadingMore = true;
          const nextBatch = Math.min(itemsPerLoad, allProducts.length - displayedProductsCount);
          const itemsToAdd = allProducts.slice(displayedProductsCount, displayedProductsCount + nextBatch);
          
          renderResults(itemsToAdd, true); // Append mode
          displayedProductsCount += nextBatch;
          
          isLoadingMore = false;
          
          // Update summary
          summariseResults(allProducts.length);
        }

        // Setup infinite scroll listener
        function setupInfiniteScroll() {
          const resultsSection = document.getElementById('dashboardResults');
          if (!resultsSection) return;

          // Remove old scroll listener if exists
          if (window.infiniteScrollHandler) {
            window.removeEventListener('scroll', window.infiniteScrollHandler);
            window.removeEventListener('wheel', window.infiniteScrollHandler);
          }

          window.infiniteScrollHandler = () => {
            if (isLoadingMore) return;
            if (displayedProductsCount >= allProducts.length) return;

            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;
            
            // Load more when user is 300px from bottom
            if (documentHeight - (scrollTop + windowHeight) < 300) {
              loadMoreProducts();
            }
          };

          window.addEventListener('scroll', window.infiniteScrollHandler, { passive: true });
          window.addEventListener('wheel', window.infiniteScrollHandler, { passive: true });
        }

        // Initialize infinite scroll when results are shown
        // Starts by displaying first 50 products, then loads 50 more as user scrolls
        function initializeInfiniteScroll() {
          if (!allProducts || allProducts.length === 0) {
            console.warn('initializeInfiniteScroll called but allProducts is empty');
            if (resultsBody) {
              resultsBody.innerHTML = '<div class="results-empty">No products to display.</div>';
            }
            return;
          }
          
          displayedProductsCount = Math.min(itemsPerLoad, allProducts.length);
          const productsToRender = allProducts.slice(0, displayedProductsCount);
          
          console.log(`üé® Rendering ${productsToRender.length} products (out of ${allProducts.length} total)`);
          renderResults(productsToRender);
          setupInfiniteScroll();
        }

        // Update pagination info (footer removed, just log for debugging)
        function updatePaginationInfo() {
          // Log product counts to console for debugging
          console.log(`üìä Products Status: ${displayedProductsCount} displayed out of ${allProducts.length} total products fetched`);
        }

        // Fetch results directly from Miros API (no popup)
        async function fetchMirosResultsDirectly(type, options) {
          const { url, itemId, query, category, limit = 15 } = options;
          let mirosData = [];

          // First, introspect schema to find available queries
          const schema = await introspectMirosSchema();
          const availableQueries = schema?.__schema?.queryType?.fields || [];

          if (type === 'url') {
            // Extract product name from URL for text search
            // URL format: .../SPLASH-Striped-Sleeveless-Polo-Dress/p/1025360
            // Extract the product name part before /p/
            let urlQuery = url.split('/p/')[0].split('/').pop().replace(/-/g, ' ');
            console.log('Extracted product name from URL for search:', urlQuery);

            // Use autocompleteSuggestionsPage for URL-based search
            const searchQuery = availableQueries.find(q => 
              q.name === 'autocompleteSuggestionsPage'
            );

            if (!searchQuery) {
              throw new Error('Autocomplete suggestions query not available');
            }

            const queryName = searchQuery.name;
            const queryArg = searchQuery.args?.find(a => a.name === 'query');
            const isInputObject = queryArg?.type?.ofType?.name === 'AutocompleteSuggestionsQuery';
            
            // Get actual fields available on AutocompleteSuggestionsPage
            const returnType = searchQuery.type?.ofType;
            const availableFields = returnType?.fields?.map(f => f.name) || [];
            console.log('AutocompleteSuggestionsPage available fields:', availableFields);
            
            // Build query dynamically based on what fields actually exist
            let fieldsToQuery = '';
            
            // Common patterns - try to find which one exists
            if (availableFields.includes('edges')) {
              fieldsToQuery = `
                edges {
                  node {
                    itemId
                    title
                    url
                    imageUrl
                  }
                }
              `;
            } else if (availableFields.includes('items')) {
              fieldsToQuery = `
                items {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else if (availableFields.includes('nodes')) {
              fieldsToQuery = `
                nodes {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else if (availableFields.includes('suggestions')) {
              fieldsToQuery = `
                suggestions {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else if (availableFields.includes('data')) {
              fieldsToQuery = `
                data {
                  itemId
                  title
                  url
                  imageUrl
                }
              `;
            } else {
              // If none of the common patterns exist, query ALL available fields
              // This will help us see what's actually there
              fieldsToQuery = availableFields.slice(0, 10).map(field => `
                ${field}
              `).join('');
              console.warn('Using all available fields:', availableFields.slice(0, 10));
            }
            
            // autocompleteSuggestionsPage expects AutocompleteSuggestionsQuery input object, not String
            const queryStr = `
              query AutocompleteSuggestions($integration_id: ID!, $slot: Int!, $query: AutocompleteSuggestionsQuery!) {
                ${queryName}(integration_id: $integration_id, slot: $slot, query: $query) {
                  ${fieldsToQuery}
                }
              }
            `;

            // AutocompleteSuggestionsQuery is an input object - need to pass object with text/q field
            const variables = {
              integration_id: MIROS_INTEGRATION_ID,
              slot: MIROS_SLOT,
              query: { text: urlQuery } // Try 'text' field first
            };

            try {
              let data;
              try {
                data = await callMirosAPI(queryStr, variables);
              } catch (error) {
                // Try with 'q' field if 'text' fails
                if (variables.query.text) {
                  variables.query = { q: urlQuery };
                  data = await callMirosAPI(queryStr, variables);
                } else {
                  throw error;
                }
              }
              
              // autocompleteSuggestionsPage might return edges/nodes or items
              const results = data[queryName];
              if (results?.edges && Array.isArray(results.edges)) {
                mirosData = results.edges.map(e => e.node).filter(Boolean);
              } else if (results?.items && Array.isArray(results.items)) {
                mirosData = results.items;
              } else if (results?.nodes && Array.isArray(results.nodes)) {
                mirosData = results.nodes;
              } else if (Array.isArray(results)) {
                mirosData = results;
              } else if (results && typeof results === 'object') {
                mirosData = results.data || results.results || [];
              }
            } catch (error) {
              console.error('URL search query failed:', error);
              throw error;
            }

          } else if (type === 'item') {
            // For item/SKU search, use autocompleteSuggestionsPage with the itemId as query
            const searchQuery = availableQueries.find(q => 
              q.name === 'autocompleteSuggestionsPage'
            );

            if (!searchQuery) {
              throw new Error('Autocomplete suggestions query not available');
            }

            const queryName = searchQuery.name;
            
            // Get actual fields available on AutocompleteSuggestionsPage
            const returnType = searchQuery.type?.ofType;
            const availableFields = returnType?.fields?.map(f => f.name) || [];
            console.log('AutocompleteSuggestionsPage available fields:', availableFields);
            
            // Build query dynamically based on what fields actually exist
            let fieldsToQuery = '';
            if (availableFields.includes('edges')) {
              fieldsToQuery = `edges { node { itemId title url imageUrl } }`;
            } else if (availableFields.includes('items')) {
              fieldsToQuery = `items { itemId title url imageUrl }`;
            } else if (availableFields.includes('nodes')) {
              fieldsToQuery = `nodes { itemId title url imageUrl }`;
            } else if (availableFields.includes('suggestions')) {
              fieldsToQuery = `suggestions { itemId title url imageUrl }`;
            } else {
              // Query all available fields to see structure
              fieldsToQuery = availableFields.slice(0, 10).join(' ');
              console.warn('Using all available fields:', availableFields.slice(0, 10));
            }
            
            const queryStr = `
              query AutocompleteSuggestions($integration_id: ID!, $slot: Int!, $query: AutocompleteSuggestionsQuery!) {
                ${queryName}(integration_id: $integration_id, slot: $slot, query: $query) {
                  ${fieldsToQuery}
                }
              }
            `;

            const variables = {
              integration_id: MIROS_INTEGRATION_ID,
              slot: MIROS_SLOT,
              query: { text: itemId }
            };

            try {
              let data;
              try {
                data = await callMirosAPI(queryStr, variables);
              } catch (error) {
                variables.query = { q: itemId };
                data = await callMirosAPI(queryStr, variables);
              }
              
              const results = data[queryName];
              if (results?.edges && Array.isArray(results.edges)) {
                mirosData = results.edges.map(e => e.node).filter(Boolean);
              } else if (results?.items && Array.isArray(results.items)) {
                mirosData = results.items;
              } else if (results?.nodes && Array.isArray(results.nodes)) {
                mirosData = results.nodes;
              } else if (Array.isArray(results)) {
                mirosData = results;
              } else if (results && typeof results === 'object') {
                mirosData = results.data || results.results || [];
              }
            } catch (error) {
              console.error('Item search query failed:', error);
              throw error;
            }

          } else if (type === 'nlp') {
            // Find autocompleteSuggestionsPage query (this is what's available)
            const searchQuery = availableQueries.find(q => 
              q.name === 'autocompleteSuggestionsPage'
            );

            if (!searchQuery) {
              // If no search query exists, we might need to use widget or different approach
              throw new Error('Search query not available in GraphQL schema. You may need to use the Miros widget or check API documentation.');
            }

            const queryName = searchQuery.name;
            const args = searchQuery.args || [];
            
            console.log(`Using search query: ${queryName} with args:`, args.map(a => a.name));

            // Get actual fields available on AutocompleteSuggestionsPage
            const returnType = searchQuery.type?.ofType;
            const availableFields = returnType?.fields?.map(f => f.name) || [];
            console.log('AutocompleteSuggestionsPage available fields:', availableFields);
            
            // Build query dynamically based on what fields actually exist
            let fieldsToQuery = '';
            if (availableFields.includes('edges')) {
              fieldsToQuery = `edges { node { itemId title url imageUrl } }`;
            } else if (availableFields.includes('items')) {
              fieldsToQuery = `items { itemId title url imageUrl }`;
            } else if (availableFields.includes('nodes')) {
              fieldsToQuery = `nodes { itemId title url imageUrl }`;
            } else if (availableFields.includes('suggestions')) {
              fieldsToQuery = `suggestions { itemId title url imageUrl }`;
            } else {
              // Query all available fields to see structure
              fieldsToQuery = availableFields.slice(0, 10).join(' ');
              console.warn('Using all available fields:', availableFields.slice(0, 10));
            }
            
            // autocompleteSuggestionsPage requires: integration_id, slot, query (AutocompleteSuggestionsQuery input object)
            const queryStr = `
              query AutocompleteSuggestions($integration_id: ID!, $slot: Int!, $query: AutocompleteSuggestionsQuery!) {
                ${queryName}(integration_id: $integration_id, slot: $slot, query: $query) {
                  ${fieldsToQuery}
                }
              }
            `;

            const variables = {
              integration_id: MIROS_INTEGRATION_ID,
              slot: MIROS_SLOT,
              query: { text: query } // AutocompleteSuggestionsQuery is an input object
            };

            try {
              let data;
              try {
                data = await callMirosAPI(queryStr, variables);
              } catch (error) {
                // Try with 'q' field if 'text' fails
                variables.query = { q: query };
                data = await callMirosAPI(queryStr, variables);
              }
              
              // autocompleteSuggestionsPage might return edges/nodes or items
              const results = data[queryName];
              if (results?.edges && Array.isArray(results.edges)) {
                mirosData = results.edges.map(e => e.node).filter(Boolean);
              } else if (results?.items && Array.isArray(results.items)) {
                mirosData = results.items;
              } else if (results?.nodes && Array.isArray(results.nodes)) {
                mirosData = results.nodes;
              } else if (Array.isArray(results)) {
                mirosData = results;
              } else if (results && typeof results === 'object') {
                mirosData = results.data || results.results || [];
              }
            } catch (error) {
              console.error('Autocomplete suggestions query failed:', error);
              throw error;
            }
          }

          return mirosData.slice(0, limit).map(transformMirosResult);
        }

        // Helper to extract items from various Miros response structures
        function extractItemsFromMirosResponse(data) {
          // Try different possible response structures
          if (data.autocompleteSuggestionsPage) {
            const page = data.autocompleteSuggestionsPage;
            return page.edges?.map(e => e.node) || 
                   page.items || 
                   page.nodes || 
                   page.suggestions || 
                   [];
          }
          if (data.search) {
            return Array.isArray(data.search) ? data.search : [];
          }
          if (data.itemRecommendations) {
            return Array.isArray(data.itemRecommendations) ? data.itemRecommendations : [];
          }
          return [];
        }

        // Listen for Miros widget events and extract results
        function setupMirosWidgetListener() {
          // Method 1: Listen for custom events from widget
          window.addEventListener('miros-results-loaded', (event) => {
            if (event.detail && event.detail.items) {
              const items = event.detail.items.map(transformMirosResult);
              appendUniqueProducts(items);
            }
          });

          // Method 2: Intercept network requests to capture widget's API responses
          const originalFetch = window.fetch;
          window.fetch = function(...args) {
            const url = args[0];
            if (typeof url === 'string' && url.includes('miros.services')) {
              return originalFetch.apply(this, args).then(response => {
                const clonedResponse = response.clone();
                clonedResponse.json().then(data => {
                  if (data && data.data) {
                    // Try to extract items from various response structures
                    const items = extractItemsFromMirosResponse(data.data);
                    if (items && items.length > 0) {
                      console.log('Captured items from widget API:', items);
                      const transformed = items.map(transformMirosResult);
                      appendUniqueProducts(transformed);
                    }
                  }
                }).catch(() => {});
                return response;
              });
            }
            return originalFetch.apply(this, args);
          };

          // Method 3: Use MutationObserver to watch widget DOM for results
          const observer = new MutationObserver((mutations) => {
            // Look for product elements in the widget overlay
            const widgetOverlay = document.querySelector('[data-miros-overlay], .miros-overlay, .miros-container, [id*="miros"]');
            if (widgetOverlay) {
              const productElements = widgetOverlay.querySelectorAll('[data-item-id], [data-product-id], .product-item, .suggestion-item, [data-suggestion]');
              if (productElements.length > 0) {
                const items = Array.from(productElements).map(el => {
                  const titleEl = el.querySelector('.title, .product-title, [data-title], h3, h4');
                  const linkEl = el.querySelector('a');
                  const imgEl = el.querySelector('img');
                  
                  return {
                    productTitle: titleEl?.textContent?.trim() || el.getAttribute('data-title') || el.getAttribute('alt') || '-',
                    optionId: el.getAttribute('data-item-id') || el.getAttribute('data-option-id') || el.getAttribute('data-product-id') || '-',
                    url: linkEl?.href || el.getAttribute('data-url') || el.getAttribute('href') || '',
                    imageUrl: imgEl ? (imgEl.src || imgEl.getAttribute('src') || '') : '',
                  };
                });
                if (items.length > 0) {
                  console.log('Extracted items from widget DOM:', items);
                  renderResults(items);
                  clearStatus();
                }
              }
            }
          });

          // Observe the document for widget changes
          observer.observe(document.body, {
            childList: true,
            subtree: true
          });
        }

        // Function to extract results from widget
        function tryExtractResultsFromWidget() {
          // Method 1: Check if widget exposes global API
          if (window.MirosWidget || window.miros) {
            const widget = window.MirosWidget || window.miros;
            if (widget && typeof widget.getResults === 'function') {
              widget.getResults().then(items => {
                if (items && items.length > 0) {
                  const transformed = items.map(transformMirosResult);
                  appendUniqueProducts(transformed);
                  return;
                }
              }).catch(() => {});
            }
            
            // Try other possible methods
            if (widget && typeof widget.getSuggestions === 'function') {
              widget.getSuggestions().then(items => {
                if (items && items.length > 0) {
                  const transformed = items.map(transformMirosResult);
                  appendUniqueProducts(transformed);
                }
              }).catch(() => {});
            }
          }

          // Method 2: Try to find results in DOM after a delay
          setTimeout(() => {
            const widgetOverlay = document.querySelector('[data-miros-overlay], .miros-overlay, [id*="miros"], [class*="miros"]');
            if (widgetOverlay) {
              // Look for product cards/images in the widget
              const productCards = widgetOverlay.querySelectorAll('img[src*="product"], .product-card, [data-product], [data-item-id]');
              
              if (productCards.length > 0) {
                const items = Array.from(productCards).map(card => {
                  const parent = card.closest('[data-item-id], [data-product-id], .product-item') || card.parentElement;
                  const imgEl = card.tagName === 'IMG' ? card : card.querySelector('img');
                  return {
                    productTitle: parent.querySelector('.title, .product-title, [data-title]')?.textContent?.trim() || card.getAttribute('alt') || '-',
                    optionId: parent.getAttribute('data-item-id') || card.getAttribute('data-item-id') || '-',
                    url: parent.querySelector('a')?.href || card.closest('a')?.href || '',
                    imageUrl: imgEl ? (imgEl.src || imgEl.getAttribute('src') || '') : '',
                  };
                });
                
                if (items.length > 0) {
                  appendUniqueProducts(items);
                }
              }
            }
          }, 1000);
        }

        // Miros Overlay Button Functions (NO scraping - overlay is independent)
        // Flag to enable/disable overlay button (set to false to revert to previous state)
        const ENABLE_MIROS_OVERLAY_BUTTON = true;
        
        const prepareEntry = (attributes) => {
          prepareEntryForElement(mirosEntry, attributes);
        };
        
        const prepareEntryForElement = (element, attributes) => {
          if (!element || !ENABLE_MIROS_OVERLAY_BUTTON) return;

          const ENTRY_ATTRS = [
            "item",
            "nlp",
            "category",
            "image-url",
            "sizes",
            "lang",
          ];

          ENTRY_ATTRS.forEach((attr) => {
            const attrName = `data-miros-${attr}`;
            if (attributes[attr]) {
              element.setAttribute(attrName, attributes[attr]);
            } else {
              element.removeAttribute(attrName);
            }
          });
        };

        const openMirosOverlay = () => {
          if (!ENABLE_MIROS_OVERLAY_BUTTON) return;
          
          // The Miros widget injects an AI search button - we need to click that
          // Try multiple selectors to find the AI button
          const aiButton = 
            document.querySelector('button.miros-search-on-entry-point') ||
            document.querySelector('[class*="miros-search-on-entry-point"]') ||
            document.querySelector('button[class*="miros"][class*="search"]') ||
            document.querySelector('button[aria-label*="search" i]') ||
            document.querySelector('[data-miros-entry="miros-on-search"] button') ||
            document.querySelector('#mirosEntry button') ||
            document.querySelector('button[class*="miros-box-border"]');
          
          if (aiButton) {
            // Click the button to open overlay (no console.log to prevent spam)
            aiButton.click();
            return;
          }
          
          // Fallback: try clicking mirosEntry elements
          const entryElements = [mirosEntry, mirosEntryLanding].filter(Boolean);
          for (const entryEl of entryElements) {
            if (entryEl) {
              entryEl.click();
              entryEl.dispatchEvent(
                new MouseEvent("click", {
                  bubbles: true,
                  cancelable: true,
                  view: window,
                }),
              );
            }
          }
        };


        // Extract unique brands and colors from products
        function extractFilterOptions() {
          allBrands.clear();
          allColors.clear();
          
          originalProducts.forEach(product => {
            if (product.brand && product.brand.trim()) {
              allBrands.add(product.brand.trim());
            }
            if (product.color && product.color.trim()) {
              allColors.add(product.color.trim());
            }
          });
          
          // Debug logging
          console.log('Extracted brands:', Array.from(allBrands));
          console.log('Extracted colors:', Array.from(allColors));
          
          // Sort alphabetically
          const sortedBrands = Array.from(allBrands).sort();
          const sortedColors = Array.from(allColors).sort();
          
          populateFilterOptions('brand', sortedBrands);
          populateFilterOptions('color', sortedColors);
          
          // Filters container is always visible in filters header
          // No need to conditionally show/hide it based on products
        }

        // Populate filter dropdown options
        function populateFilterOptions(type, options) {
          const optionsContainer = document.getElementById(`${type}FilterOptions`);
          const searchInput = document.getElementById(`${type}FilterSearch`);
          if (!optionsContainer) {
            console.error(`Filter options container not found: ${type}FilterOptions`);
            return;
          }
          
          console.log(`Populating ${type} filter with ${options.length} options:`, options);
          
          optionsContainer.innerHTML = '';
          
          // If no options, show a message
          if (options.length === 0) {
            const noOptionsMsg = document.createElement('div');
            noOptionsMsg.className = 'filter-option';
            noOptionsMsg.style.padding = 'var(--spacing-sm)';
            noOptionsMsg.style.color = 'var(--color-text-tertiary)';
            noOptionsMsg.style.fontStyle = 'italic';
            noOptionsMsg.textContent = `No ${type} options available`;
            optionsContainer.appendChild(noOptionsMsg);
            return;
          }
          
          options.forEach(option => {
            const optionEl = document.createElement('div');
            optionEl.className = 'filter-option';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = `${type}-${option}`;
            checkbox.value = option;
            const selectedSet = type === 'brand' ? selectedBrands : (type === 'color' ? selectedColors : new Set());
            checkbox.checked = selectedSet.has(option);
            if (checkbox.checked) {
              optionEl.classList.add('selected');
            }
            
            checkbox.addEventListener('change', (e) => {
              const value = e.target.value;
              if (type === 'brand') {
                if (e.target.checked) {
                  selectedBrands.add(value);
                } else {
                  selectedBrands.delete(value);
                }
              } else if (type === 'color') {
                if (e.target.checked) {
                  selectedColors.add(value);
                } else {
                  selectedColors.delete(value);
                }
              }
              updateFilterUI();
              applyFilters();
            });
            
            const label = document.createElement('label');
            label.htmlFor = `${type}-${option}`;
            label.textContent = option;
            
            optionEl.appendChild(checkbox);
            optionEl.appendChild(label);
            optionsContainer.appendChild(optionEl);
          });
          
          // Add search functionality
          if (searchInput) {
            searchInput.addEventListener('input', (e) => {
              const searchTerm = e.target.value.toLowerCase();
              Array.from(optionsContainer.children).forEach(optionEl => {
                const label = optionEl.querySelector('label');
                const matches = label.textContent.toLowerCase().includes(searchTerm);
                optionEl.style.display = matches ? 'flex' : 'none';
              });
            });
          }
        }

        // Update filter UI (selected tags, clear button)
        function updateFilterUI() {
          // Update brand filter selected display
          updateFilterSelectedDisplay('brand', selectedBrands);
          // Update color filter selected display
          updateFilterSelectedDisplay('color', selectedColors);
          
          // Show/hide clear button
          const clearBtn = document.getElementById('clearFiltersBtn');
          if (clearBtn) {
            clearBtn.style.display = (selectedBrands.size > 0 || selectedColors.size > 0) ? 'block' : 'none';
          }
        }

        function updateFilterSelectedDisplay(type, selectedSet) {
          const selectedContainer = document.getElementById(`${type}FilterSelected`);
          const selectedFiltersContainer = document.getElementById('selectedFiltersContainer');
          
          // Always show placeholder in dropdown trigger when closed
          if (selectedContainer) {
            const placeholder = selectedContainer.querySelector('.filter-placeholder');
            const textContainer = selectedContainer.querySelector('.filter-multiselect__selected-text');
            
            // Remove any tags from inside the dropdown trigger
            if (textContainer) {
              textContainer.innerHTML = '';
            }
            
            // Always show placeholder in dropdown trigger
            if (placeholder) {
              placeholder.style.display = 'block';
              if (selectedSet.size > 0) {
                placeholder.textContent = `${selectedSet.size} selected`;
              } else {
                const placeholderText = type === 'brand' ? 'Select brands...' : (type === 'color' ? 'Select colors...' : 'Select...');
                placeholder.textContent = placeholderText;
              }
            }
          }
          
          // Render selected tags in the external container
          if (!selectedFiltersContainer) return;
          
          // Clear existing tags for this filter type
          const existingTags = selectedFiltersContainer.querySelectorAll(`[data-filter-type="${type}"]`);
          existingTags.forEach(tag => tag.remove());
          
          if (selectedSet.size === 0) {
            // Hide container if no filters selected
            const hasAnyFilters = selectedFiltersContainer.children.length > 0;
            if (!hasAnyFilters) {
              selectedFiltersContainer.style.display = 'none';
            }
          } else {
            // Show container
            selectedFiltersContainer.style.display = 'flex';
            
            // Create tags for selected filters
            selectedSet.forEach(value => {
              const tag = document.createElement('span');
              tag.className = 'filter-tag';
              tag.setAttribute('data-filter-type', type);
              tag.innerHTML = `
                ${value}
                <button type="button" class="filter-tag__remove" data-type="${type}" data-value="${value}">√ó</button>
              `;
              selectedFiltersContainer.appendChild(tag);
            });
            
            // Add remove handlers
            selectedFiltersContainer.querySelectorAll('.filter-tag__remove').forEach(btn => {
              // Remove existing listeners by cloning
              const newBtn = btn.cloneNode(true);
              btn.parentNode.replaceChild(newBtn, btn);
              
              newBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const filterType = newBtn.dataset.type;
                const filterValue = newBtn.dataset.value;
                if (filterType === 'brand') {
                  selectedBrands.delete(filterValue);
                } else if (filterType === 'color') {
                  selectedColors.delete(filterValue);
                }
                updateFilterUI();
                applyFilters();
              });
            });
          }
        }

        // Apply filters to products
        function applyFilters() {
          // Always use originalProducts for filtering (preserve full dataset)
          const sourceProducts = originalProducts.length > 0 ? originalProducts : allProducts;
          
          // Apply brand filter
          let filtered = sourceProducts;
          if (selectedBrands.size > 0) {
            filtered = filtered.filter(product => {
              const brand = (product.brand || '').trim();
              return brand && selectedBrands.has(brand);
            });
          }
          
          // Apply color filter
          if (selectedColors.size > 0) {
            filtered = filtered.filter(product => {
              const color = (product.color || '').trim();
              return color && selectedColors.has(color);
            });
          }
          
          // Update displayed products with filtered results
          displayedProductsCount = 0;
          allProducts = filtered; // Use filtered for rendering
          
          // Only render if we have products
          if (allProducts.length > 0) {
            initializeInfiniteScroll();
          } else {
            // Show empty message if no filtered results
            if (resultsBody) {
              resultsBody.innerHTML = '<div class="results-empty">No products match the selected filters.</div>';
            }
            summariseResults(0);
            updatePaginationInfo();
          }
        }

        // Setup filter dropdown toggles
        function setupFilterDropdowns() {
          ['brand', 'color'].forEach(type => {
            const selectedEl = document.getElementById(`${type}FilterSelected`);
            const dropdownEl = document.getElementById(`${type}FilterDropdown`);
            
            if (selectedEl && dropdownEl) {
              selectedEl.addEventListener('click', (e) => {
                e.stopPropagation();
                const isOpen = dropdownEl.style.display !== 'none';
                
                // Close all dropdowns
                document.querySelectorAll('.filter-multiselect__dropdown').forEach(dd => {
                  dd.style.display = 'none';
                  dd.classList.remove('dropdown-above');
                });
                document.querySelectorAll('.filter-multiselect__selected').forEach(sel => {
                  sel.classList.remove('active');
                });
                
                if (!isOpen) {
                  dropdownEl.style.display = 'flex';
                  selectedEl.classList.add('active');
                  
                  // Check if dropdown would go below viewport, position above if needed
                  setTimeout(() => {
                    const rect = selectedEl.getBoundingClientRect();
                    const dropdownHeight = dropdownEl.offsetHeight || 300; // Default max height
                    const spaceBelow = window.innerHeight - rect.bottom;
                    const spaceAbove = rect.top;
                    
                    // If not enough space below but enough space above, position above
                    if (spaceBelow < dropdownHeight && spaceAbove > dropdownHeight) {
                      dropdownEl.classList.add('dropdown-above');
                    } else {
                      dropdownEl.classList.remove('dropdown-above');
                    }
                  }, 10);
                }
              });
            }
          });
          
          // Close dropdowns when clicking outside
          document.addEventListener('click', (e) => {
            if (!e.target.closest('.filter-multiselect')) {
              document.querySelectorAll('.filter-multiselect__dropdown').forEach(dd => {
                dd.style.display = 'none';
              });
              document.querySelectorAll('.filter-multiselect__selected').forEach(sel => {
                sel.classList.remove('active');
              });
            }
          });
          
          // Clear filters button
          const clearBtn = document.getElementById('clearFiltersBtn');
          if (clearBtn) {
            clearBtn.addEventListener('click', () => {
              selectedBrands.clear();
              selectedColors.clear();
              
              // Uncheck all brand filter checkboxes
              const brandFilterOptions = document.getElementById('brandFilterOptions');
              if (brandFilterOptions) {
                const checkboxes = brandFilterOptions.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                  checkbox.checked = false;
                  const optionEl = checkbox.closest('.filter-option');
                  if (optionEl) {
                    optionEl.classList.remove('selected');
                  }
                });
              }
              
              // Uncheck all color filter checkboxes
              const colorFilterOptions = document.getElementById('colorFilterOptions');
              if (colorFilterOptions) {
                const checkboxes = colorFilterOptions.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                  checkbox.checked = false;
                  const optionEl = checkbox.closest('.filter-option');
                  if (optionEl) {
                    optionEl.classList.remove('selected');
                  }
                });
              }
              
              updateFilterUI();
              applyFilters();
            });
          }
        }

        // Upload image and get data URL (no backend needed - widget handles it)
        const uploadImageToMiros = async (file) => {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            
            reader.onload = (e) => {
              const imageUrl = e.target.result; // Data URL
              resolve({ imageUrl });
            };
            
            reader.onerror = () => {
              reject(new Error("Failed to read image file"));
            };
            
            reader.readAsDataURL(file);
          });
        };


        // Main search function - API only method
        const performSearch = async () => {
            clearStatus();
            const rawValue = searchInput.value.trim();

            if (!rawValue) {
              showStatus("Enter a search term or SKU to continue.", "error");
              return;
            }
            
            // Store current search query for filename generation
            currentSearchQuery = rawValue;

          // CRITICAL: Transition to STATE 2 immediately when search is clicked
          if (!hasSearched) {
            showResultsSection();
          }

          prepareResultsForNewSearch();

          // Check if API key is available
          if (!MIROS_API_KEY) {
            showStatus("API key is required. Please configure MIROS_API_KEY.", "error");
            setTimeout(() => clearStatus(), 3000);
            return;
          }

          // Fetch all products via API only
            showStatus("Fetching products via Miros API...", "pending");
            try {
            console.log('=== Starting API fetch - fetching all available products ===');
            console.log(`Search term: "${rawValue}"`);
            
            const apiResults = await fetchProductsViaAPI(rawValue);
            console.log(`üì• API fetch returned ${apiResults.length} products`);

            if (apiResults.length > 0) {
              console.log(`‚ûï Adding ${apiResults.length} products from API to table`);
              appendUniqueProducts(apiResults, { reset: true, silent: false });
              console.log(`üìä FINAL COUNT: ${allProducts.length} total products fetched and stored`);
              console.log(`üí° To check products anytime, type in console: allProducts.length`);
              showStatus(`Successfully loaded ${allProducts.length} products via Miros API.`, "success");
              // Show Miros entry button after successful search (if enabled)
              if (ENABLE_MIROS_OVERLAY_BUTTON) {
                // Prepare entry with current search query
                const isSku = /^[A-Za-z0-9_-]+$/.test(rawValue);
                const attributes = {};
                if (isSku) {
                  attributes.item = rawValue;
                  attributes.nlp = "";
                } else {
                  attributes.item = "";
                  attributes.nlp = rawValue;
                }
                prepareEntry(attributes);
                
                setTimeout(() => {
                  showMirosEntryButton();
                }, 500);
              }
              setTimeout(() => clearStatus(), 3000);
                } else {
              console.log(`‚ö†Ô∏è No products found for search: "${rawValue}"`);
              showStatus("No results found. Try a different search term or SKU.", "error");
              setTimeout(() => clearStatus(), 3000);
            }
          } catch (error) {
            console.error('Miros API fetch failed:', error);
            showStatus(`API error: ${error.message || 'Failed to fetch products'}. Please check your API key and try again.`, "error");
            setTimeout(() => clearStatus(), 5000);
          }
        };

        // Attach search to both buttons - ensure focus mode exits

        // Generate filename based on search query and selected filters
        function generateFileName() {
          // Get current search query (from input or stored value)
          const searchTerm = currentSearchQuery || (searchInput ? searchInput.value.trim() : '') || 'Search';
          
          // Format search term: capitalize first letter of each word
          const formattedSearch = searchTerm
            .split(' ')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
            .join(' ');
          
          // Build filename parts
          const filenameParts = [formattedSearch];
          
          // Handle brand filters
          const brandCount = selectedBrands.size;
          if (brandCount > 0) {
            if (brandCount === 1) {
              // Single brand: show brand name
              const brandName = Array.from(selectedBrands)[0];
              filenameParts.push(brandName);
            } else {
              // Multiple brands: show count
              filenameParts.push(`${brandCount}Brands`);
            }
          }
          
          // Handle color filters
          const colorCount = selectedColors.size;
          if (colorCount > 0) {
            filenameParts.push(`${colorCount}Colors`);
          }
          
          // Join parts with underscores and sanitize filename
          let fileName = filenameParts.join('_');
          
          // Sanitize filename: remove invalid characters for file names
          fileName = fileName
            .replace(/[<>:"/\\|?*]/g, '') // Remove invalid characters
            .replace(/\s+/g, ' ') // Normalize whitespace
            .trim();
          
          // Add date if no filters selected (fallback)
          if (brandCount === 0 && colorCount === 0) {
            fileName += `_${new Date().toISOString().split("T")[0]}`;
          }
          
          return `${fileName}.xlsx`;
        }

        // Download results as Excel file
        if (downloadButton) {
          downloadButton.addEventListener("click", () => {
            try {
              if (allProducts.length === 0) {
                showStatus("No results to download.", "error");
                setTimeout(() => clearStatus(), 2000);
                return;
              }

              if (typeof XLSX === "undefined") {
                showStatus("Excel library not loaded. Please refresh the page.", "error");
                setTimeout(() => clearStatus(), 3000);
                return;
              }

              // Headers for CSV export
              const headers = ["Product Title", "Brand", "SKU / Product ID", "Product URL", "Image URL"];

              // Export ALL fetched products (up to 5,000), not just what's currently displayed
              // This ensures users get the complete dataset in CSV even if they haven't scrolled through all products
              const data = allProducts.map((item) => {
                const productId = deriveProductIdFromSource(item.url, item.optionId);
                
                return [
                  item.productTitle || "-",
                  item.brand || "-",
                  productId || "-",
                  item.url || "-",
                  item.imageUrl || "-"
                ];
              });

              const worksheetData = [headers, ...data];
              const wb = XLSX.utils.book_new();
              const ws = XLSX.utils.aoa_to_sheet(worksheetData);

              const colWidths = headers.map((_, index) => {
                const maxLength = worksheetData.reduce((max, row) => {
                  const cell = row[index] || "";
                  return Math.max(max, cell.toString().length);
                }, 10);
                return { wch: Math.min(Math.max(maxLength + 2, 12), 60) };
              });
              ws["!cols"] = colWidths;

              XLSX.utils.book_append_sheet(wb, ws, "Search Results");
              const fileName = generateFileName();
              XLSX.writeFile(wb, fileName);

              showStatus("Results downloaded successfully!", "success");
              setTimeout(() => clearStatus(), 2000);
            } catch (error) {
              console.error("Download failed:", error);
              showStatus("Could not download results. Check console for details.", "error");
              setTimeout(() => clearStatus(), 3000);
            }
          });
        }

        // Initialize widget listener when page loads
        setupMirosWidgetListener();

        // Initialize filter dropdowns
        setupFilterDropdowns();
        
        // Initialize Miros buttons on page load
        initializeMirosButtons();

        // Initialize infinite scroll when page loads
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', () => {
            setupInfiniteScroll();
            initializeMirosButtons();
          });
        } else {
          setupInfiniteScroll();
          initializeMirosButtons();
        }
      })();
    </script>
    
  </body>
</html>


